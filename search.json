[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Dart for Everybody",
    "section": "",
    "text": "1 Introduction\nEmbarking on the Coding Adventure: The Pragmatic and the Philosophical\n\n1.0.1 Welcome to the World of Coding\nAhoy, future coder! Buckle up for a wild ride into the world of programming. It’s a bit like Hogwarts, but instead of waving wands and uttering Latin spells, you’ll wield a keyboard and summon magic with lines of code. Like a well-brewed potion, coding combines logic, creativity, and just a dash of audacity to manifest digital wonders. So, ready to swap your quill for a keyboard?\n\n\n1.0.2 Why Dart?\n“But why Dart?” you might wonder, with the digital world buzzing with so many coding languages. Well, Dart is the dashing, versatile hero of our coding saga. Simple to learn, flexible to use, and potent enough to create anything from mobile apps to web wizardry. If you’ve heard of Flutter, the super-framework for building eye-popping user interfaces, yep, that’s Dart’s baby.\n\n\n1.0.3 The Programmer’s Mindset\nCoding isn’t just about talking to machines; it’s about cultivating a mental toolkit every bit as important as your coding skills. Think of it as learning to brew your potion - it involves precision, experimentation, and a fair share of spilled ingredients. Coding is a marathon, not a sprint. Well, more like a fun run where you get to design the track, the backdrop, and the finish line.\n\n\n1.0.4 Embracing Errors & Iterative Improvement\nImagine casting a new spell. Do you get it right the first time? Probably not. You’ll likely turn your teacher into a toad or something. Coding, much like spellcasting, involves a lot of trials, a ton of errors, and an infinite capacity for laughter. You’ll make mistakes, and that’s not just okay—it’s fantastic! Each error is a clue, leading you on a treasure hunt to a better solution.\n\n\n1.0.5 Coding, Creativity, and Community\nCoding isn’t a lonely wizard locked in a tower; it’s a magical feast at Hogwarts’ Great Hall! It’s where creativity meets collaboration. Programming communities are like a House Cup competition, but everybody wins! You’ll code together, debug together, and create together. Every Hermione needs a Ron and Harry, after all.\n\n\n1.0.6 What lies ahead?\nThis book is like your very own Marauder’s Map. It will guide you from the fundamental spells (think: Dart syntax, data types) through the dark forests of control flow and functions to the enchanting world of classes. By the end, you’ll be creating magic with code, just like Dumbledore, but with fewer beard issues.\nSo, are you ready to step onto platform 9 ¾ and board the Dart Express? There’s a whole world of programming magic waiting to be discovered. Let the journey begin!"
  },
  {
    "objectID": "building_blocks.html",
    "href": "building_blocks.html",
    "title": "2  Building Blocks",
    "section": "",
    "text": "Variables and Data Types\nOperators\nDocumentation"
  },
  {
    "objectID": "building_blocks/variables_and_data_types.html#magic-potions-and-spells-dart-variables-and-data-types",
    "href": "building_blocks/variables_and_data_types.html#magic-potions-and-spells-dart-variables-and-data-types",
    "title": "3  Variables and Data Types",
    "section": "3.1 Magic Potions and Spells: Dart Variables and Data Types",
    "text": "3.1 Magic Potions and Spells: Dart Variables and Data Types\nWelcome, future Dart wizards, to another enchanting chapter of our coding adventure. Today, we’ll explore the mystical world of Dart variables and data types. You’ll make variables dance to your tunes and morph data types like a true sorcerer by the end."
  },
  {
    "objectID": "building_blocks/variables_and_data_types.html#whats-in-a-name-everything-when-its-a-variable",
    "href": "building_blocks/variables_and_data_types.html#whats-in-a-name-everything-when-its-a-variable",
    "title": "3  Variables and Data Types",
    "section": "3.2 What’s in a name? Everything, when it’s a Variable!",
    "text": "3.2 What’s in a name? Everything, when it’s a Variable!\nFirst up, let’s meet our shapeshifter friend - Variables. They’re the magical containers in programming, storing, and changing their content as you command. They’re like the Room of Requirement in Harry Potter – they can become anything you need them to be. Need to remember a user’s name? Variables to the rescue. Want to calculate the score of your cheese-rolling game? Variables have your back!"
  },
  {
    "objectID": "building_blocks/variables_and_data_types.html#the-wonderful-world-of-data-types",
    "href": "building_blocks/variables_and_data_types.html#the-wonderful-world-of-data-types",
    "title": "3  Variables and Data Types",
    "section": "3.3 The Wonderful World of Data Types",
    "text": "3.3 The Wonderful World of Data Types\nNow, imagine trying to stuff an elephant into a suitcase or pour an ocean into a teacup; impossible, right? That’s where data types come into play. There are different kinds of boxes in Dart - sorry, I mean variables - to store different kinds of data. You have:\n\nNumbers: Dart gives you two types of numeric containers, int for whole numbers (like the number of cats you own) and double for fractional ones (like the exact amount of coffee you drink daily in liters).\n\nint numberOfCats = 5; // You have five adorable cats\ndouble litersOfCoffee = 0.75; // You drink 0.75 liters of coffee a day, cheers!\nStrings: These are for text. Remember the name of your first pet or your favorite quote? Those are strings, and they are always written between ‘single quotes’ or “double quotes.”\nString petName = 'Fluffy'; // Your pet's name is Fluffy, aww!\nString favoriteQuote = \"Coffee first, schemes later.\"; // Wise choice\nBooleans: These are the simplest of data types, storing only true or false. They’re like the light switches of the coding world, deciding the path of your conditionals.\nbool lovesCoding = true; // You love coding, right?"
  },
  {
    "objectID": "building_blocks/variables_and_data_types.html#declaring-and-assigning-variables---lets-get-the-party-started",
    "href": "building_blocks/variables_and_data_types.html#declaring-and-assigning-variables---lets-get-the-party-started",
    "title": "3  Variables and Data Types",
    "section": "3.4 Declaring and Assigning Variables - Let’s Get the Party Started!",
    "text": "3.4 Declaring and Assigning Variables - Let’s Get the Party Started!\nNow that we have our Dart-flavored containers, let’s fill them up. Declaring a variable is like sending a party invitation to a specific data type. You’re telling it to reserve a spot in the memory and wait for the party to start.\nString party; // Declared a variable named 'party' of type 'String'\nAssigning a variable, on the other hand, is like kicking off the party by filling that memory spot with a value.\nparty = 'Started'; // The party has started!\nYou can also do both at once - send the invitation and start the party:\nString party = 'Started'; // Declared and assigned in one line"
  },
  {
    "objectID": "building_blocks/variables_and_data_types.html#final-const-var-and-late---the-special-keywords",
    "href": "building_blocks/variables_and_data_types.html#final-const-var-and-late---the-special-keywords",
    "title": "3  Variables and Data Types",
    "section": "3.5 Final, Const, Var, and Late - The Special Keywords",
    "text": "3.5 Final, Const, Var, and Late - The Special Keywords\nThink of these as the VIPs of the Dart world.\n\nfinal: This keyword is used when you have a variable you don’t want to change after it’s assigned. It’s like a stubborn cat that found a comfortable spot on the couch and won’t move, no matter what.\n\nfinal String favoriteFood = 'Pizza'; // Pizza is love, Pizza is life\nconst: This is for values you know are constant and won’t change even before runtime, like a day has 24 hours or a minute has 60 seconds.\nconst int hoursInDay = 24; // Time is constant... unless you're Doctor Who\nvar: Dart’s version of “Whatever!”. If you’re feeling a bit lazy and want to avoid defining the data type, Dart’s got your back. It will figure out the data type based on the value you assign.\nvar lazyVar = 'I am a string'; // Dart knows this is a string\nlate: This is Dart’s way of saying, “Better late than never”. Use this when you want to declare a variable but can’t immediately assign it a value.\nlate String lateToTheParty; // We'll assign this variable later\nSo, that’s your introductory crash course on Dart variables and data types. Remember, practice is key to mastering these concepts. So, start brewing your magic potions and casting your spells, and remember to have fun while you’re at it!"
  },
  {
    "objectID": "building_blocks/operators.html#conjuring-magic-operators-in-dart",
    "href": "building_blocks/operators.html#conjuring-magic-operators-in-dart",
    "title": "4  Operators",
    "section": "4.1 Conjuring Magic: Operators in Dart",
    "text": "4.1 Conjuring Magic: Operators in Dart\nGather ’round, code sorcerers! It’s time to expand your Dart-spelling repertoire by adding a new chapter of incantations - the Operators. Just as you’d expect, these aren’t your run-of-the-mill wand-waving tricks. These special symbols wield the power to perform actions and operations on our code.\nThink of operators as the action heroes of programming. They swing, leap, and even backflip over your variables and data, performing everything from magical math transformations to logical labyrinths. And, Dart, being the fantastic magical realm it is, gives you a plethora of operators, each serving a unique purpose. Based on their stunts, we can categorize Dart operators into different troops.\nBefore we dive into this magical whirlpool, remember: with great power comes great responsibility. So, prepare to command these operators with wisdom and valor, or at least with a cup of coffee and a slice of pizza! Stay tuned for the upcoming action-packed performance from our brave Dart operators. Trust me; it’ll be spellbinding!\nArithmetic\nAssignment\nBitwise\nComparison\nLogical\nType"
  },
  {
    "objectID": "building_blocks/operators/arithmetic.html",
    "href": "building_blocks/operators/arithmetic.html",
    "title": "5  Arithmetic",
    "section": "",
    "text": "5.0.1 Mathemagic with Arithmetic Operators\nLadies and Gentlemen, it’s time to pull out your magic wands - I mean, your keyboards - for our first act, the incredible, the unbelievable, the math-defying Arithmetic Operators!\nRemember those characters you’ve met back in your Math class? Yes, the ones that liked adding apples and subtracting oranges! They’re here, and they’ve got their game face on. In Dart, they’ve got some cool tricks up their sleeves:\n\n+ The Addition Operator: This is like the super-friendly operator who’s always eager to bring things together. Have a couple of numbers? The addition operator will happily unite them for you.\n\nint cats = 5;\nint dogs = 3;\nint totalPets = cats + dogs; // You have 8 lovely pets now.\n- The Subtraction Operator: This operator is the detective of the group, always finding the difference. Feed it two numbers, and it’ll tell you how far apart they are.\nint cakes = 10;\nint eatenCakes = 3;\nint remainingCakes = cakes - eatenCakes; // Still got 7 delicious cakes.\n* The Multiplication Operator: Imagine you have a magic spell to duplicate things. That’s what the multiplication operator does, making your numbers multiply!\nint hours = 24;\nint days = 7;\nint hoursInWeek = hours * days; // Abracadabra, there are 168 hours in a week.\n/ The Division Operator: The peacekeeper of the group, the division operator evenly distributes one value among another, just like cutting a pie into equal pieces.\nint pie = 10;\nint friends = 2;\ndouble piePerFriend = pie / friends; // Each friend gets 5.0 pieces of pie.\n% The Modulus Operator: This sneaky operator is all about the leftovers. Divide one number by another, and the modulus will tell you what’s remaining.\nint totalCandies = 11;\nint numberofKids = 3;\nint leftoverCandies = totalCandies % numberofKids; // 2 candies left after sharing among 3 kids.\nJust like that, our mathemagicians are making wonders happen with your code. Now, it’s your turn. Grab those operators and start crafting your own spells. Remember, every great wizard starts with the basics!"
  },
  {
    "objectID": "building_blocks/operators/assignment.html",
    "href": "building_blocks/operators/assignment.html",
    "title": "6  Assignment",
    "section": "",
    "text": "6.0.1 Charm Casting with Assignment Operators\nLend me your ears, magical coders, for the next spectacular act of our thrilling Dart journey - the mesmerizing, the enchanting, Assignment Operators!\nAssignment operators are like the ultimate multitaskers of the Dart world. They juggle operations and assignments all at once, giving your fingers a well-deserved break from all that typing.\n\n= The Basic Assignment Operator: This operator is the team’s workhorse. It’s just here to assign values to variables, no questions asked.\n\nint cupcakes = 12; // You've got 12 cupcakes!\n+= The Addition Assignment Operator: This operator adds a dash of magic to the plain old assignment. It adds a value to a variable and then assigns the result back to the variable. Imagine a potion that grows sweeter with each spoon of sugar you add.\nint sugar = 5; // 5 spoons of sugar\nsugar += 3; // Now it's 8, sweetness overload!\n-= The Subtraction Assignment Operator: This operator is here to balance the sweetness. It subtracts a value from a variable and reassigns the result back to the variable.\nint coffee = 10; // Start with 10 cups of coffee\ncoffee -= 2; // You drank 2, so you have 8 left\n*= The Multiplication Assignment Operator: Like a charm that multiplies whatever it touches, this operator multiplies a variable by a value and assigns the result back to the variable.\nint cats = 2; // 2 cats\ncats *= 3; // Magic spell! Now you've got 6 cats!\n/= The Division Assignment Operator: This operator believes in equal sharing. It divides a variable by a value and reassigns the result back to the variable.\ndouble pizza = 12.0; // 12 slices of pizza\npizza /= 4; // You share with 3 friends, so everyone gets 3 slices\n• %= The Modulus Assignment Operator: This operator is all about the leftovers. It applies modulus to a variable and assigns the result back to the variable.\nint candies = 15; // Start with 15 candies\ncandies %= 4; // You share with 3 friends, and you have 3 candies left\nWith these charmed Assignment Operators at your disposal, the magic of Dart is now yours to command. Practice these incantations and make your own magic. Code on, wizards!"
  },
  {
    "objectID": "building_blocks/operators/bitwise.html",
    "href": "building_blocks/operators/bitwise.html",
    "title": "7  Bitwise",
    "section": "",
    "text": "7.0.1 The Binary Circus: Bitwise Operators\nLadies and gentlemen, robots and AI, prepare yourselves for a dazzling dive into the digital depths of Dart. A realm where 0s and 1s juggle, tumble, and twist into patterns of pure logic. Welcome to the grand show of Bitwise Operators!\nImagine a grand binary ballet, where each 0 and 1 pirouettes gracefully at the command of these mystical operators. There are six primary dancers in this ballet:\n\n& The Bitwise AND Operator: It’s like the picky eater of the group. This operator looks at the matching bits of two numbers and only takes a bite when both are 1. Otherwise, it starves (returns 0).\n\nint firstNumber = 170;  // Binary: 10101010\nint secondNumber = 240; // Binary: 11110000\nint result = firstNumber & secondNumber; // Result: 160 (Binary: 10100000)\n| The Bitwise OR Operator: The exact opposite of our AND operator, this one’s the foodie. If either of the matching bits is 1, it chomps down, satisfied.\nresult = firstNumber | secondNumber; // Result: 250 (Binary: 11111010)\n^ The Bitwise XOR Operator: XOR is the rebel - it thrives on difference. It takes a peek at the matching bits, and only when they’re different it munches (returns 1).\nresult = firstNumber ^ secondNumber; // Result: 90 (Binary: 01011010)\n~ The Bitwise NOT Operator: This is the dramatic one. It takes a binary number and flips all its bits in a grand gesture.\nresult = ~firstNumber; // Result: -171 (Binary: 01010101)\n&lt;&lt; The Left Shift Operator: Imagine a marching band where every time the drum rolls, everyone takes a step to the left. That’s what the left shift operator does, but with bits.\nresult = firstNumber &lt;&lt; 2; // Result: 680 (Binary: 1010100000)\n&gt;&gt; The Right Shift Operator: As you’d guess, this operator is all about marching to the right. A drumroll, and all bits step right.\nresult = firstNumber &gt;&gt; 2; // Result: 42 (Binary: 00101010)\nWith these bitwise operators, you can choreograph your own binary ballets, creating more intricate patterns and magical performances within your Dart code. So, take the stage, and let the binary ballet begin!"
  },
  {
    "objectID": "building_blocks/operators/comparison.html#why-the-parentheses",
    "href": "building_blocks/operators/comparison.html#why-the-parentheses",
    "title": "8  Comparison",
    "section": "8.1 Why the parentheses?",
    "text": "8.1 Why the parentheses?\nNow, you might be wondering why we swaddle our comparisons in parentheses like newborn babies. It’s not just because they look cute that way (though they absolutely do)! Parentheses in programming help us establish a clear order of operations—ensuring our diligent judges make their proclamations at the right time, every time. So wrap those comparisons up snug and tight, for they have a big role to play in your Dart code!\nAnd thus, we conclude our visit to the Court of Comparisons. Remember, in the court of Dart Comparison Operators, truth and falsity are equally important. They’re the yin and yang that keep the cosmos of your code balanced. Happy comparing!"
  },
  {
    "objectID": "building_blocks/operators/logical.html",
    "href": "building_blocks/operators/logical.html",
    "title": "9  Logical",
    "section": "",
    "text": "9.0.1 Welcome to the Boolean Ballroom: Logical Operators\nAre you ready to join the dance of decisions, the waltz of wisdom, the samba of sanity checks? Then, let’s step into the Boolean Ballroom, where Dart’s Logical Operators, the maestros of the Boolean Orchestra, make the magic happen. These operators weave together Boolean values (our darling dancers known as true and false) into a fantastic dance of logic and reason.\nHere are our talented choreographers:\n\n&& The Logical AND Duet: This performance requires both dancers (Boolean values) to be true for the entire dance to be a success. If even one dancer forgets a step (becomes false), the dance is not the same.\n\nbool perfectDuet = (true && true); // True! Both dancers nailed it!\nbool stumbledDuet = (true && false); // False! One of the dancers missed a beat. Keep practicing!\n|| The Logical OR Ensemble: This is a more forgiving performance. The dance will still shine as long as at least one of our dancers performs flawlessly (is true).\nbool amazingEnsemble = (false || true); // True! One dancer’s incredible spin saved the day!\n! The Logical NOT Solo: The prima donna of logical operations, it only requires one dancer. This solo performance is a curious one, as the dancer always performs the opposite of what they rehearsed.\nbool unexpectedSolo = !true; // False! Wait, we thought they were going to perform a true!\nRemember, our Boolean Ballroom depends on perfect timing. So, ensure that you have your conditions and Boolean values in the right order. A misstep in logic can lead to an entirely different dance!\nWith that, our show in the Boolean Ballroom concludes. Don your top hat, dust off your tailcoat, and ready your Boolean dancers for the next performance in the Dart Disco!"
  },
  {
    "objectID": "building_blocks/operators/type.html",
    "href": "building_blocks/operators/type.html",
    "title": "10  Type",
    "section": "",
    "text": "10.0.1 All Aboard the Type Test Express: is and is!\nBuckle up, coding comrades! We’re about to embark on a thrilling journey aboard the Type Test Express, the one-stop solution to avoid the pitfalls of type confusion. Dart’s type test operators are like the friendly conductors checking tickets, making sure everyone (or in our case, every variable) is in the right place.\nThere are two conductors in our train analogy, is and is!, and they handle our passengers - variables - with care and precision.\n\nis The Identity Inspector: This operator, like an attentive conductor, checks if a variable is of a certain type. If it is, it responds with a courteous nod (returns true). But if it’s not, it shakes its head (returns false).\n\nvar aTrainTicket = 'Choo Choo!';\nprint(aTrainTicket is String); // True! This ticket is indeed a string.\nis! The Non-Identity Inspector: This operator has an edgier approach. Instead of checking if a variable is of a certain type, it checks if it is not of a certain type. If the variable’s type does not match, it gives a triumphant thumbs-up (true). But if it does match, it frowns in disappointment (false).\nprint(aTrainTicket is! int); // True! Our ticket is no integer, it's a string!\nThese conductors, is and is!, are here to keep our code on track, making sure that all variables are precisely what we expect them to be. Just remember, when in doubt, give a shout out to is and is!.\nSo, as we pull into our next station, the Land of Control Flow, remember to keep your variables in check and your types in order!"
  },
  {
    "objectID": "building_blocks/documentation.html",
    "href": "building_blocks/documentation.html",
    "title": "11  Documentation",
    "section": "",
    "text": "The importance of comments and how to write good documentation for your code is an often overlooked art.\nThis chapter will be written soon…"
  },
  {
    "objectID": "steering_code.html#flow-control-and-functions",
    "href": "steering_code.html#flow-control-and-functions",
    "title": "12  Steering the Code",
    "section": "12.1 Flow Control and Functions",
    "text": "12.1 Flow Control and Functions\nWelcome, thrilled carnival-goers and spellbound wizards, to the enchanting spectacle of “Steering the Code”! Much like orchestrating a grand carnival or casting a powerful spell, coding too requires choreography and craft. In this section, we’ll delve into two magical aspects of coding, Flow Control and Functions, the carnival rides and enchantments that lead you through the mesmerizing maze of your code.\nFlow Control is your guide through the bustling carnival of programming; it’s the lively carnival barker who decides which thrilling rides to experience based on various circumstances. Whether it’s choosing between the swirling Ferris Wheel or the exciting Roller Coaster (our conditional statements), or going for a second spin on the carousel (our loops), flow control lets your code adapt and react to all the lively happenings of the carnival.\nThen we have Functions, the magical spells of our programming world. These are enchanting incantations that perform specific tricks again and again, without the need to recite the entire spell every time. Just like a magic spell can turn a frog into a prince with a single word, functions can streamline your code, making it efficient, readable, and easier to debug.\nSo, step right up folks! Join us as we dive into the whirl of carnival rides and the realm of magical enchantments in steering our code with Flow Control and Functions. Grab your carnival tickets and magic wands, fellow programmers, for an unforgettable coding adventure awaits you!\nFlow Control\nFunctions"
  },
  {
    "objectID": "steering_code/flow_control.html",
    "href": "steering_code/flow_control.html",
    "title": "13  Flow Control",
    "section": "",
    "text": "14 The Flow Control Fiesta\nLadies and gentlemen, hold on to your keyboards because we’re about to embark on a wild, thrilling ride through the Dart programming language’s carnival of control flow! Here, we have an amazing array of attractions that help us steer the logic of our programs."
  },
  {
    "objectID": "steering_code/flow_control.html#conditional-statements-the-mystical-if-else-labyrinth",
    "href": "steering_code/flow_control.html#conditional-statements-the-mystical-if-else-labyrinth",
    "title": "13  Flow Control",
    "section": "14.1 Conditional Statements: The Mystical “if-else” Labyrinth",
    "text": "14.1 Conditional Statements: The Mystical “if-else” Labyrinth\nImagine stepping into a labyrinth where every turn you take is based on a true-or-false condition. That’s our dazzling if-else maze!\nHere’s our brave contestant weatherIsNice, set to either true or false.\nbool weatherIsNice = true; // It's a sunny day!\nBased on this adventurous variable, our contestant will decide which turn to take:\nif (weatherIsNice) {\n    print(\"Let's go for a picnic!\"); // If the weather is nice, we're going on a picnic!\n} else {\n    print(\"Let's stay home and code.\"); // If the weather is not nice, more time for coding!\n}\nJust remember, our if-else labyrinth never leads you astray!"
  },
  {
    "objectID": "steering_code/flow_control.html#loop-a-loop-roller-coaster-the-fabulous-for-loop",
    "href": "steering_code/flow_control.html#loop-a-loop-roller-coaster-the-fabulous-for-loop",
    "title": "13  Flow Control",
    "section": "14.2 Loop-a-Loop Roller Coaster: The Fabulous “for” Loop",
    "text": "14.2 Loop-a-Loop Roller Coaster: The Fabulous “for” Loop\nNext, brace yourself for the exhilarating Loop-a-Loop roller coaster, where repetition reigns supreme!\nfor (int rideCount = 1; rideCount &lt;= 5; rideCount++) {\n    print(\"This is ride number $rideCount!\");\n}\nThe for loop is like a roller coaster ride with three important parts:\n\nThe Seat Belt Check (int rideCount = 1): This is where we prepare for the ride. We set our rideCount to 1, indicating we’re about to embark on the first ride.\nThe Safety Bar (rideCount &lt;= 5): This is our safety constraint. We continue riding as long as rideCount is less than or equal to 5. Once we exceed 5 rides, safety regulations dictate that it’s time for a break!\nThe Exciting Loop (rideCount++): This is the thrilling part where we go around the loop. After each ride, we increment rideCount by 1, marking off another exhilarating loop on our ride.\n\nStrap in as you watch rideCount go from 1 to 5 in the blink of an eye, taking you through the loop each time!"
  },
  {
    "objectID": "steering_code/flow_control.html#waiting-in-line-the-for-in-loop",
    "href": "steering_code/flow_control.html#waiting-in-line-the-for-in-loop",
    "title": "13  Flow Control",
    "section": "14.3 Waiting in line: the for-in loop",
    "text": "14.3 Waiting in line: the for-in loop\nNow, let’s step deeper into the magical world of Dart looping and meet for-in, a spellbinding variation of for that’s more commonly known as each in other programming lands. The for-in loop graciously invites every item in a list to a fabulous dance, one at a time.\nvar rollerCoasterRiders = ['Anna', 'Bob', 'Charlie'];\n\nfor (var rider in rollerCoasterRiders) {\n    print('$rider is ready to ride the Loop-a-Loop roller coaster!');\n}\nOur for-in loop is like a carnival barker, calling each eager roller coaster rider from the rollerCoasterRiders list to take their turn on the Loop-a-Loop roller coaster. Isn’t it just enchanting? Dart certainly knows how to host a spectacular code carnival!"
  },
  {
    "objectID": "steering_code/flow_control.html#the-never-ending-carousel-the-whirling-while-loop",
    "href": "steering_code/flow_control.html#the-never-ending-carousel-the-whirling-while-loop",
    "title": "13  Flow Control",
    "section": "14.4 The Never-ending Carousel: The Whirling “while” Loop",
    "text": "14.4 The Never-ending Carousel: The Whirling “while” Loop\nDon’t forget to take a whirl on our Never-ending Carousel! As long as a condition holds true, you’re going for another spin!\nint lollipopCount = 10;\nwhile (lollipopCount &gt; 0) {\n    print(\"Eating a lollipop...\");\n    lollipopCount--;\n}\nprint(\"All lollipops are gone. Time for another ride!\");\nOur hero here keeps devouring lollipops until there are none left, making for a delicious and dizzying journey."
  },
  {
    "objectID": "steering_code/flow_control.html#dowhile-loops-the-at-least-once-loop",
    "href": "steering_code/flow_control.html#dowhile-loops-the-at-least-once-loop",
    "title": "13  Flow Control",
    "section": "14.5 Do…While Loops: the at-least-once loop",
    "text": "14.5 Do…While Loops: the at-least-once loop\nJust like how some carnival games might keep you hooked until you win a prize, a do-while loop performs a task at least once, and then keeps doing it as long as a certain condition holds true. Let’s put this in a Dart context:\nint gamesPlayed = 0;\ndo {\n  print(\"Playing game number ${gamesPlayed + 1}... Let's win that stuffed unicorn!\");\n  gamesPlayed++;\n} while (gamesPlayed &lt; 5);\nIn this example, gamesPlayed keeps track of the number of games we’ve played. We’re committed to playing at least one game (gotta win that stuffed unicorn!), so the code inside the do block executes first. After each game, the gamesPlayed counter increases. If the number of games is less than 5, we go for another round, if not, we’re finally out of the do-while funhouse!"
  },
  {
    "objectID": "steering_code/flow_control.html#break-the-safety-hatch",
    "href": "steering_code/flow_control.html#break-the-safety-hatch",
    "title": "13  Flow Control",
    "section": "14.6 Break: The Safety Hatch",
    "text": "14.6 Break: The Safety Hatch\nThe break statement is like a shortcut to escape the dizzying rides. If you’re riding the carousel and start feeling dizzy, you would want to hop off right away, even if the ride isn’t over. Let’s check this out with some Dart code:\nfor (int carouselRides = 1; carouselRides &lt;= 10; carouselRides++) {\n  if (carouselRides &gt; 5) {\n    print(\"Oh no! We've had too much spinning on the carousel. Time to stop.\");\n    break;\n  }\n  print(\"Enjoying carousel ride number: $carouselRides\");\n}\nIn this example, carouselRides starts at 1 and, for each loop, we add another ride. But when we’ve ridden more than 5 times, the world starts spinning a bit too much! This is where the break statement comes in, allowing us to jump off the carousel right away."
  },
  {
    "objectID": "steering_code/flow_control.html#continue-next-ride-please",
    "href": "steering_code/flow_control.html#continue-next-ride-please",
    "title": "13  Flow Control",
    "section": "14.7 Continue: Next Ride Please",
    "text": "14.7 Continue: Next Ride Please\nThe continue statement is like skipping a ride you don’t like. If you come across a ride that you’re not particularly fond of (like that too-scary haunted house), you can skip it and continue to the next one. Here’s how we can do that in Dart:\nList&lt;String&gt; carnivalRides = ['Ferris Wheel', 'Carousel', 'Haunted House', 'Roller Coaster', 'Bumper Cars'];\n\nfor (var i = 0; i &lt; carnivalRides.length; i++) {\n  var currentRide = carnivalRides[i];\n  if (currentRide == 'Haunted House') {\n    print(\"Oh, no! The Haunted House is too scary. Let's skip it.\");\n    continue;  // If Haunted House is encountered, skip to the next iteration\n  }\n  print(\"Enjoying the $currentRide!\");\n}\nIn this example, we’re looping through a list of carnivalRides. When we encounter the ‘Haunted House’, we decide it’s a little too spooky and skip it, moving straight to the next ride."
  },
  {
    "objectID": "steering_code/flow_control.html#the-magical-switch-house-of-mirrors",
    "href": "steering_code/flow_control.html#the-magical-switch-house-of-mirrors",
    "title": "13  Flow Control",
    "section": "14.8 The Magical “Switch” House of Mirrors",
    "text": "14.8 The Magical “Switch” House of Mirrors\nLast but not least, step into the mysterious House of Mirrors where the magical switch statement takes the center stage. Each mirror reflects a different case, and our reflection hops from one mirror to another based on its value!\nString dartLevel = 'beginner';\n\nswitch (dartLevel) {\n    case 'beginner':\n        print('Welcome, young apprentice! Your journey has just begun.');\n        break;\n    case 'intermediate':\n        print('You have come a long way, young warrior!');\n        break;\n    case 'expert':\n        print('Ah, Master Coder, you have mastered the Dart side of the Force!');\n        break;\n    default:\n        print('Hmm, an unidentified entity you are. Keep practicing Dart, you must.');\n}"
  },
  {
    "objectID": "steering_code/flow_control.html#wrap-up",
    "href": "steering_code/flow_control.html#wrap-up",
    "title": "13  Flow Control",
    "section": "14.9 Wrap-up",
    "text": "14.9 Wrap-up\nWell folks, that was a fantastic journey through Dart’s Flow Control Fiesta! Each of these attractions, from the if-else Labyrinth to the switch House of Mirrors, helps guide the story of our Dart code. So, practice hard, and remember - in the magical world of Dart, you’re the ride operator!\nStay tuned for our next fun-filled chapter, and until then, code on amigos and amigas!"
  },
  {
    "objectID": "steering_code/functions.html#the-fabulous-world-of-functions",
    "href": "steering_code/functions.html#the-fabulous-world-of-functions",
    "title": "14  Functions",
    "section": "14.1 The Fabulous World of Functions",
    "text": "14.1 The Fabulous World of Functions\nOnce upon a time, in the enchanted land of Dart, there existed a magical guild known as “Functions.” This extraordinary league of spells was capable of performing marvelous feats, often transforming inputs into outputs in the blink of an eye!\n\n14.1.1 Meet the Functions\nLet’s imagine functions as friendly magical creatures with various abilities. You call them by name, give them a task (your inputs), and poof! they work their magic, bringing you back a result (your output). For example, there could be a creature named sum, and if you ask sum to add 2 and 3, it’ll return 5 with a twinkle in its eye. The code for such a function would look like this:\nint sum(int a, int b) {\n  return a + b;\n}\nHere, sum is the name of the function, int a and int b are the parameters (the tasks), and a + b is the magical result. The int in front of sum tells us that our magical creature always brings back an integer as a result. Remember, types are important in Dart!\n\n\n14.1.2 A Function of Many Hats\nSometimes, a function may take on different roles depending on the task it is given. In Dart, these are known as optional and named parameters. Picture a magical creature who can juggle, dance, and sing — but it only performs the tasks you specifically ask for. Check this out:\nString introduce(String name, {String talent = 'nothing'}) {\n  return '$name can do $talent';\n}\nIf you only tell this function your name, it will assume you can do nothing (how rude!). However, if you specify your talent, it’ll sing your praises!\n\n\n14.1.3 Anonymous Functions: The Unknown Hero\nIn the Dart magical universe, there are anonymous functions too. They’re like the masked superheroes of the coding world - no names, just action! You’ll often find them sneaking around in the world of higher-order functions (more on that later) or fluttering about in the Flutter framework, bringing life to buttons and various interactive elements. Here’s how our anonymous hero might look:\nvar anonymousHero = (task) =&gt; 'Completing $task at lightning speed!';\n\n\n14.1.4 Recursive Functions: The Magic Mirror\nIn the hall of magic mirrors, a special kind of spell echoes endlessly. These are the recursive functions — functions that call themselves in their own definition. It’s a bit like a magical creature casting a spell to clone itself, then the clone casting the same spell, and so on, until a certain condition is met. Here’s an example:\nint factorial(int n) {\n  if (n &lt;= 1) return 1;\n  return n * factorial(n - 1);\n}\nIt calculates the factorial of a number (n!) by continually multiplying n by the factorial of n - 1, until n is 1.\n\n\n14.1.5 Higher-Order Functions: The Superstars\nLastly, we have the superstars of the function world: higher-order functions. These are functions that have learned to tame other functions. They can take other functions as gifts (parameters), or they can spawn new functions to do their bidding (return a function).\nFunction makeAdder(int addBy) {\n  return (int i) =&gt; addBy + i;\n}\nhis function creates a new function that can add any number to addBy.\nSo, there you have it! In the enchanted land of Dart, functions aren’t just ordinary lines of code. They are magical creatures, full of wonder and whimsy, ready to transform inputs into outputs, work magic anonymously, echo in eternity, and even control other functions. As you continue your journey, these magical creatures will be your most loyal companions, always ready to perform feats of code at your behest!\nNext up, we’ll be delving into the realm of Dart’s mythical beasts: the data structures. Stay tuned, brave adventurer!"
  },
  {
    "objectID": "working_with_data.html",
    "href": "working_with_data.html",
    "title": "15  Working With Data",
    "section": "",
    "text": "Data Structures\nCollections"
  },
  {
    "objectID": "working_with_data/data_structures.html#conjuring-and-commanding-data-structures",
    "href": "working_with_data/data_structures.html#conjuring-and-commanding-data-structures",
    "title": "16  Data Structures",
    "section": "16.1 Conjuring and Commanding Data Structures",
    "text": "16.1 Conjuring and Commanding Data Structures\n\n16.1.1 Introduction to Data Structures\nThink of data structures as the puzzle boxes of the programming world. These clever contraptions hold our precious data, much like a dragon hoards its treasure. But fear not! There’s no fire-breathing beast here, only some deceptively simple yet extremely powerful tools that you’ll soon wield like a seasoned wizard.\n\n\n16.1.2 Basic Data Structures\nThere are a few magical containers in Dart’s magic toolbelt: Arrays, Lists, Sets, and Maps.\nArrays are like a line of enthusiastic concertgoers — they keep your data in a specific order. Each element in an array has a ticket with a number (index) that indicates its place in the line.\nLists are very similar to Arrays; they are like an extensible line of fans at a pop idol meet-and-greet. Not only can the idol remember who was first, but they can also let the line grow as more fans show up.\nSets are a bit like a magic trick where duplicates disappear. If you put in ‘rabbit’, ‘hat’, ‘rabbit’, and poof! The duplicate ‘rabbit’ vanishes, leaving you with just ‘rabbit’ and ‘hat’.\nMaps, on the other hand, are like a magical dictionary. They hold key-value pairs. Imagine you have a key named ‘unicorn’ and it leads you straight to a fabulous image of a unicorn. Isn’t that neat?\n\n\n16.1.3 Working with Data Structures\nManipulating these magical containers is where the fun begins. Just like a witch brewing a potion, you can add or remove ingredients (elements), find the one that adds a certain sparkle, or sort them to have the rarest ingredient on top. All it takes is the right incantation (method)!\n\n\n16.1.4 Custom Data Structures\nSometimes, more than the provided magical containers are needed. That’s where you can concoct your own data structure using classes. Imagine creating a magic bag that, whenever you reach in, always gives you the object you need the most at that moment. With custom data structures, you can create just about anything your magical heart desires!\n\n\n16.1.5 Choosing the Right Data Structure\nPicking the right magical container is like choosing the right spell in a duel - the wrong choice could lead to disastrous consequences or just some unnecessary hassle. In our quest to become programming wizards, we must learn to consider the trade-offs of each data structure, such as memory use and performance.\n\n\n16.1.6 Practical Applications of Data Structures\nUnderstanding data structures is like having a magical map to navigate the enchanted forest of programming. Whether it’s organizing the high scores in a game, creating a social network of wizards and witches, or even plotting the quickest path to the nearest pizza parlor, data structures are the key.\n\n\n16.1.7 Complex Data Structures\nLastly, we have the elder dragons of the data structures world: trees and graphs. They might seem intimidating at first, but fear not! They’re just a different kind of puzzle box. For those brave enough to venture into this advanced territory, there are many resources to guide you. Just remember, every master wizard started as an apprentice.\nAnd with that, we conclude our magical journey through data structures. But remember, every ending is also a new beginning. With your newfound knowledge, you’re ready to conjure and command data structures in ways you never thought possible! Now, go forth and code!"
  },
  {
    "objectID": "working_with_data/collections.html#lists-the-ferris-wheel-of-dart",
    "href": "working_with_data/collections.html#lists-the-ferris-wheel-of-dart",
    "title": "17  Collections",
    "section": "17.1 Lists: The Ferris Wheel of Dart",
    "text": "17.1 Lists: The Ferris Wheel of Dart\nIn Dart, a List is like a gigantic Ferris wheel, where each gondola carries a specific value or ‘passenger.’ Much like how Ferris wheels can carry all sorts of passengers—from the thrill-seekers, the lovebirds, to those just looking to enjoy the view—Dart lists can hold a variety of data types: numbers, strings, booleans, and yes, even other lists!\nvar shoppingList = ['eggs', 'milk', 'chocolate'];\nvar listOfMyMistakes = ['forgot semicolon', 'used = instead of ==', 'infinite loop'];\nvar listofMistakesIllProbablyMakeAgain = listOfMyMistakes;\nvar paradoxicalList = ['this sentence is false', 'list of lists not containing themselves'];\nThe Dart list is a programmer’s dream-come-true Ferris wheel. No matter how high you want to go, there’s a gondola ready to take you there! Each gondola is accessed by an index, starting from 0 (yes, we programmers start counting from zero—another charming quirk to add to the ‘list of programming eccentricities’)."
  },
  {
    "objectID": "working_with_data/collections.html#maps-the-treasure-hunt-of-dart",
    "href": "working_with_data/collections.html#maps-the-treasure-hunt-of-dart",
    "title": "17  Collections",
    "section": "17.2 Maps: The Treasure Hunt of Dart",
    "text": "17.2 Maps: The Treasure Hunt of Dart\nNow, let’s move on to another exhilarating ride: Maps. A Map is like an exciting treasure hunt. Each treasure (value) in a Dart map is assigned a unique clue (key). To find the treasure, you simply follow the clue!\nvar pirateTreasure = {\n  'golden coins': 1000,\n  'precious gems': ['ruby', 'emerald', 'sapphire'],\n  'mysterious map': 'leads to another adventure'\n};\nIn our treasure hunt, 'golden coins' is a clue that leads to a treasure of 1000. Pretty cool, eh? Maps are superb when we want to link values together, just like connecting clues with treasures. Who knew coding could feel so much like a pirate adventure?"
  },
  {
    "objectID": "working_with_data/collections.html#list-and-map-methods-the-bag-of-tricks",
    "href": "working_with_data/collections.html#list-and-map-methods-the-bag-of-tricks",
    "title": "17  Collections",
    "section": "17.3 List and Map Methods: The Bag of Tricks",
    "text": "17.3 List and Map Methods: The Bag of Tricks\nWhile we’ve introduced Lists and Maps and their superpowers, it’s time to take a deep dive into their toolboxes. You see, Lists and Maps in Dart aren’t just storage units; they’re like that handy multi-tool you take on a camping trip.\nLet’s consider a list shoppingList of items you want to buy.\nList&lt;String&gt; shoppingList = ['toothpaste', 'shampoo', 'sponge', 'bananas'];\nIf you suddenly remember that you need bread, instead of creating a new list, you can use the add() method:\nshoppingList.add('bread');\nAnd voila! Your shopping list now includes bread. But let’s say you’ve picked up a bread-making hobby, and you no longer need bread in your list. Simply use remove():\nshoppingList.remove('bread');\nSimilarly, Maps aren’t just simple old treasure maps. They are more like GPS systems that come with a range of features. Given a map favoriteFoods:\nMap&lt;String, String&gt; favoriteFoods = {\n  'Alice': 'Pizza',\n  'Bob': 'Pasta',\n};\nIf we find out that Charlie loves Tacos, we don’t need a new map. Just use putIfAbsent():\nfavoriteFoods.putIfAbsent('Charlie', () =&gt; 'Tacos');\nAnd there you have it! Charlie and his love for Tacos have officially made it to the favoriteFoods map!"
  },
  {
    "objectID": "working_with_data/collections.html#sets-the-unique-snowflakes",
    "href": "working_with_data/collections.html#sets-the-unique-snowflakes",
    "title": "17  Collections",
    "section": "17.4 Sets: The Unique Snowflakes",
    "text": "17.4 Sets: The Unique Snowflakes\nSets are a lot like the attendees of an exclusive party: no one likes duplicates! A Set is a collection of unique items. Think of it as a box where you put snowflakes. You wouldn’t want two identical snowflakes now, would you?\nIn the following code, Sets are like that exclusive VIP lounge. There’s no particular order, and no duplicate guests are allowed. Alice won’t get in twice, even if she changes her disguise!\nvoid main() {\n  Set&lt;String&gt; vipLounge = {'Alice', 'Bob', 'Charlie', 'Alice'};\n\n  print(vipLounge.length); // 3 party-goers in the VIP!\n  print(vipLounge.contains('Alice')); // Alice made it into the VIP? Yes, she did!\n  vipLounge.add('Dave'); // Dave's on the list, too!\n  print(vipLounge); // Check out who's in the VIP lounge now!\n}\n\n17.4.1 Set operations\nSets have some special powers that make them a bit different than other collections.\nImagine we’re at a food court area now, and we have two friends, Alice and Bob. Each of them has a set of foods they want to try at the carnival.\nLet’s explore the union operation, which gives us a set of all unique items in both sets. In the context of our carnival, this will give us all unique food items that either Alice or Bob wants to try.\n\nvoid main() {\n  // Foods Alice wants to try\n  Set&lt;String&gt; aliceFoods = {'Popcorn', 'Cotton Candy', 'Churros'};\n  \n  // Foods Bob wants to try\n  Set&lt;String&gt; bobFoods = {'Hotdog', 'Popcorn', 'Nachos'};\n\n  // Foods that either Alice or Bob wants to try\n  Set&lt;String&gt; unionFoods = aliceFoods.union(bobFoods);\n\n  print('Either Alice or Bob wants to try these foods: $unionFoods');\n  // Outputs: Either Alice or Bob wants to try these foods: {Popcorn, Cotton Candy, Churros, Hotdog, Nachos}\n}\nAs you can see, the union method returns a new Set that contains all the elements of both the original Sets. In this case, it’s all the foods that either Alice or Bob wants to try. Notice how ‘Popcorn’ only appears once in the union set, despite both Alice and Bob wanting to try it. That’s because Sets only contain unique items.\nI hope this example gives you a better understanding of the union operation on Dart Sets. Enjoy your carnival treats!"
  },
  {
    "objectID": "working_with_data/collections.html#queues",
    "href": "working_with_data/collections.html#queues",
    "title": "17  Collections",
    "section": "17.5 Queues",
    "text": "17.5 Queues\nNow, imagine a Queue as the line for the hot dog stand. In this line, it’s a strict “first come, first served” policy. The first one to line up will be the first one to get their hot dog!\nimport 'dart:collection';\n\nvoid main() {\n  Queue&lt;int&gt; hotDogLine = Queue();\n  \n  hotDogLine.addLast(1); // Customer No.1 joins the queue!\n  hotDogLine.addLast(2); // Customer No.2 is next!\n  hotDogLine.addLast(3); // Customer No.3 takes the last spot!\n  \n  print(hotDogLine.removeFirst()); // Customer No.1 gets his hot dog!\n  print(hotDogLine); // Let's see who's still waiting for their hot dog!\n}"
  },
  {
    "objectID": "working_with_data/collections.html#iterables-and-loops-the-theme-park-ride",
    "href": "working_with_data/collections.html#iterables-and-loops-the-theme-park-ride",
    "title": "17  Collections",
    "section": "17.6 Iterables and Loops: The Theme Park Ride",
    "text": "17.6 Iterables and Loops: The Theme Park Ride\nRemember the roller coaster ride of loops we discussed earlier? Now, combine that with Lists and Maps, and you have an entire theme park of data to explore. You can loop over Lists and Maps, accessing and manipulating data as you whizz by!\nAll these tricks and tools make Lists, Maps, and Sets not just containers for storing data but multifunctional devices that can be manipulated and traversed in many ways. After all, programming isn’t just about storing values; it’s about playing with them!"
  },
  {
    "objectID": "working_with_data/collections.html#multi-dimensional-lists-sets-and-maps-the-rabbit-holes",
    "href": "working_with_data/collections.html#multi-dimensional-lists-sets-and-maps-the-rabbit-holes",
    "title": "17  Collections",
    "section": "17.7 Multi-Dimensional Lists, Sets, and Maps: The Rabbit Holes",
    "text": "17.7 Multi-Dimensional Lists, Sets, and Maps: The Rabbit Holes\nJust like in Alice in Wonderland, things can get much more complex in the world of Lists and Maps. Lists can store other lists, and maps can store other maps. Picture a giant matryoshka doll situation, except it’s with data structures."
  },
  {
    "objectID": "working_with_data/collections.html#conclusion",
    "href": "working_with_data/collections.html#conclusion",
    "title": "17  Collections",
    "section": "17.8 Conclusion",
    "text": "17.8 Conclusion\nJust like that, at our Dart Programming Carnival, we ensure a fun and fair time for all! The use of collections like List, Map, Set, and Queue can provide a structured way to juggle data, akin to juggling colorful juggling balls at this grand carnival!\nIn the land of Dart, Lists, Maps, and Sets are the kings and queens. They provide a multitude of options to store, access, and manipulate data. They’re the powerful allies you want by your side as you embark on your programming journey. So keep practicing, and in no time, you’ll become a data structure wizard! Remember, it’s all just a bit of hocus-pocus with a dash of data."
  },
  {
    "objectID": "supercharging_dart.html",
    "href": "supercharging_dart.html",
    "title": "18  Supercharging Your Dart",
    "section": "",
    "text": "Asynchronous Programming\nRegular Expressions\nNumeric Computing\nOrganizing Your Code"
  },
  {
    "objectID": "supercharging_dart/asynchronous_programming.html#sip-savor-and-async---asynchronous-programming-in-dart",
    "href": "supercharging_dart/asynchronous_programming.html#sip-savor-and-async---asynchronous-programming-in-dart",
    "title": "19  Asynchronous Programming",
    "section": "19.1 Sip, Savor, and Async - Asynchronous Programming in Dart",
    "text": "19.1 Sip, Savor, and Async - Asynchronous Programming in Dart\nWelcome to our next exciting chapter. Remember the last time you and your friends decided to hit your favorite café? You walked into the smell of freshly ground coffee beans, the sound of the espresso machine, and an overwhelming choice of tempting treats.\nProgramming, my dear friend, is no different than this café. Just like you’ve got multiple things going on, from ordering your food to catching up with your friends, a computer program often needs to do several things at once. So, let’s get caffeinated and dive right into the world of synchronous and asynchronous programming!\n\n19.1.1 Synchronous vs Asynchronous Programming\nImagine this scenario. You and your friends step into the café. You approach the counter to order. “One cappuccino, please,” you say. The barista starts preparing your coffee right away. But until your coffee is ready, nobody else can order. Your friends have to wait until your coffee is done. Sounds pretty annoying, right? Well, this, my friends, is an example of synchronous programming.\nIn contrast, asynchronous programming would go a little like this: You place your order, the barista nods, and then you step aside. Your friends can place their orders too. The barista works on the orders as they came in. Everybody gets a buzzer that will notify them when their order is ready. In the meantime, you’re all free to find a seat, chat, or scroll through your social media. Much better, isn’t it?\n\n\n19.1.2 Futures\nIn Dart, the concept of a “future” is central to understanding async programming. In our café analogy, a future is like your buzzer. When you place an order, you’re handed a buzzer. This buzzer is a promise that your order will be ready at some point in the future.\nIn Dart, when we have an operation that might take a while to complete (like querying a database, downloading a file, or in this case, preparing a delicious cappuccino), we represent this operation as a Future. When the Future completes, it’ll either hold the result of the operation or an error, in case something went wrong.\nFuture&lt;String&gt; makeCoffee(String order) async {\n    var coffee = await barista.prepareCoffee(order);\n    return 'Your $coffee is ready!';\n}\n\n\n19.1.3 Async and Await\nThe async and await keywords are the superheroes of Dart’s asynchronous programming. You can think of them as the digital version of your buzzer and you waiting for your coffee.\nvoid main() async {\n    print('Placing order for cappuccino...');\n    var coffee = await makeCoffee('cappuccino');\n    print(coffee);\n}\nThe async keyword tells Dart that some asynchronous operations are happening within that function, and await tells Dart to wait for a Future to complete and extract its value.\n\n\n19.1.4 Error handling in Async programming\nSometimes, things don’t go according to plan. Maybe the café ran out of your favorite cinnamon rolls, or perhaps the barista accidentally spilled your coffee. When things go awry in asynchronous programming, you need to handle these errors gracefully.\nFuture&lt;String&gt; makeCoffee(String order) async {\n    try {\n        var coffee = await barista.prepareCoffee(order);\n        return 'Your $coffee is ready!';\n    } catch (error) {\n        throw 'Oh no, there was a problem making your $order!';\n    }\n}\n\n\n19.1.5 Streams\nLastly, let’s talk about streams. Imagine you’re sitting at your table, and you see your barista making drinks one after another, each one a different order. In Dart, a stream is a way to receive a sequence of events, one after another. You can think of it as having a front-row seat to watching the barista in action, with each completed order being an event in the stream.\nclass Order {\n    String personName;\n    String drinkName;\n    Duration preparationTime;\n\n    Order(this.name, this.drinkName, this.preparationTime);\n}\n\nclass Barista {\n    Future&lt;Order&gt; makeOrder(Order order) async {\n        print('Preparing {$order.drinkName} for ${order.personName}...');\n        await Future.delayed(order.preparationTime);\n                print('Order is prepared.');\n        return order;\n    }\n}\n\nStream&lt;Order&gt; baristaMakingOrders(Barista barista, List&lt;Order&gt; orders) async* {\n    for (var order in orders) {\n        yield await barista.makeOrder(order);\n    }\n}\n\nvoid main() {\n    var barista = Barista();\n    var orders = [\n        Order('Alice', 'Latte', Duration(minutes: 2)),\n        Order('Bob', 'Mocaccino', Duration(minutes: 3)),\n        Order('Charlie', 'Espresso', Duration(minutes: 1)),\n    ];\n\n    var subscription = baristaMakingOrders(barista, orders).listen(\n        (Order order) {\n            print('${order.beverageName} is ready for ${order.personName}');\n        },\n        onError: (err) {\n            print('Oh no, there was a problem: $err');\n        },\n        onDone: () {\n            print('The barista has finished all the orders!');\n        }\n    );\n}\nThe code above models a café scenario where a barista is preparing drinks for a series of orders. It leverages Dart’s asynchronous programming capabilities to simulate the process of making a drink, which takes a certain amount of time. This process is modeled using a Future, and the sequence of drink orders is represented as a Stream. Here is a more detailed breakdown of the different parts of this code:\nThe Order class: This class represents an order placed by a person in the café. Each Order object has a personName (the name of the person who placed the order), a drinkName (the type of drink ordered), and a preparationTime (the amount of time it takes to prepare the drink).\nThe Barista class: This class represents the barista who is preparing the drinks. The Barista class has a single method, makeOrder, which takes an Order as input. This method returns a Future&lt;Order&gt;, simulating the asynchronous process of making a drink. The makeOrder method first prints a message saying it’s preparing the drink, then “waits” for a duration equal to the order’s preparation time using the Future.delayed function. After the delay, it prints a message saying the order is prepared and returns the Order.\nThe baristaMakingOrders function: This is an asynchronous generator function that takes a Barista and a List&lt;Order&gt; as input. For each Order in the list, it waits for the Barista to finish making the order, then yields the Order. Because it uses the yield keyword, this function returns a Stream&lt;Order&gt;, which emits each completed order as soon as it’s ready.\nThe main function: This function sets up the scenario and runs the simulation. It first creates a Barista and a list of Orders. Then, it calls the baristaMakingOrders function and subscribes to the resulting Stream&lt;Order&gt;. The listen method is called on the Stream to handle the Order events it emits. This function takes three arguments:\n\nA callback function that gets called whenever a new Order is ready. This function simply prints a message saying the drink is ready for the person who ordered it.\nAn onError callback that gets called if there’s an error while preparing an order. This function prints an error message.\nAn onDone callback that gets called when all orders have been completed. This function prints a message saying the barista has finished all the orders.\n\nThis code provides a practical and relatable demonstration of asynchronous programming in Dart, showing how Futures and Streams can be used to manage time-consuming tasks and sequences of events."
  },
  {
    "objectID": "supercharging_dart/regular_expressions.html#section",
    "href": "supercharging_dart/regular_expressions.html#section",
    "title": "20  Regular Expressions",
    "section": "20.1 ",
    "text": "20.1 \nThe Treasure Hunt of The Secret Code Society\n“Welcome, brave ones, to the Secret Code Society, a mysterious world where each symbol and character holds its own secret power. Regular expressions are our magic spells, weaving characters together to find the hidden treasures amidst the sea of text. So, put on your detective caps, and let’s unravel the enigma of Dart’s regular expressions.”"
  },
  {
    "objectID": "supercharging_dart/regular_expressions.html#the-basics-the-map-to-the-treasure",
    "href": "supercharging_dart/regular_expressions.html#the-basics-the-map-to-the-treasure",
    "title": "20  Regular Expressions",
    "section": "20.2 The Basics: The Map to the Treasure",
    "text": "20.2 The Basics: The Map to the Treasure\nvoid main() {\n  var re = RegExp(r'\\b[A-Z]\\w*\\b');\n  print(re.allMatches('In The Secret Code Society, Every Clue Counts').length); // 8\n}\nThis, my friends, is the map to your first treasure. Here, \\b[A-Z]\\w*\\b is the cryptic instruction set by the society. It translates to “find every word starting with a capital letter”. \\b is the boundary between a word and a non-word, [A-Z] is any uppercase letter, and \\w* is any word character (letter, number, or underscore) appearing zero or more times.\nThe magic spell, re.allMatches, reveals the number of treasures hidden in the sentence. Here, it unearths seven!"
  },
  {
    "objectID": "supercharging_dart/regular_expressions.html#the-number-riddle-decoding-numerical-clues",
    "href": "supercharging_dart/regular_expressions.html#the-number-riddle-decoding-numerical-clues",
    "title": "20  Regular Expressions",
    "section": "20.3 The Number Riddle: Decoding Numerical Clues",
    "text": "20.3 The Number Riddle: Decoding Numerical Clues\nvoid main() {\n  var re = RegExp(r'\\d+');\n  print(re.hasMatch('Find The 7 Hidden Treasures')); // true\n}\nHere’s a number riddle for you! Sometimes, the clues are hidden in the form of numbers. The spell \\d+ means “find one or more digits”. It’s like the society’s secret number detector, sniffing out numerical secrets. hasMatch then checks if our riddle, ‘Find The 7 Hidden Treasures’, indeed contains such a secret. It joyfully returns true - yes, a hidden number was found!"
  },
  {
    "objectID": "supercharging_dart/regular_expressions.html#word-puzzles-the-jigsaw-of-characters",
    "href": "supercharging_dart/regular_expressions.html#word-puzzles-the-jigsaw-of-characters",
    "title": "20  Regular Expressions",
    "section": "20.4 Word Puzzles: The Jigsaw of Characters",
    "text": "20.4 Word Puzzles: The Jigsaw of Characters\nvoid main() {\n  var re = RegExp(r'cl\\w*');\n  final match = re.firstMatch('In the Secret Code Society, every clue counts')!;\n  print(match[0]);\n}\nAt times, you’ll encounter a jigsaw of characters. Here, cl\\w* decodes to “find any word starting with ‘cl’”. It’s like having a jigsaw piece and looking for the rest of the puzzle. firstMatch then tells us the first word it found to fit this puzzle in our sentence. And lo and behold, it found ‘clue’!"
  },
  {
    "objectID": "supercharging_dart/regular_expressions.html#the-laughing-sphinx-lighter-moments-in-the-society",
    "href": "supercharging_dart/regular_expressions.html#the-laughing-sphinx-lighter-moments-in-the-society",
    "title": "20  Regular Expressions",
    "section": "20.5 The Laughing Sphinx: Lighter Moments in The Society",
    "text": "20.5 The Laughing Sphinx: Lighter Moments in The Society\nWhy don’t secret agents use regular expressions?\nBecause they don’t like anything that captures!\nAh, a little humor to brighten our cryptic journey! Remember, while regular expressions can appear baffling, they’re nothing but a fun, coded treasure hunt. Each symbol, each character is part of the magic, forming patterns that unlock the mysteries of text.\nSo, keep your wits about you, Secret Code Society members, and enjoy this journey of unraveling Dart’s regular expressions. Onwards to the next treasure!"
  },
  {
    "objectID": "supercharging_dart/numeric_computing.html",
    "href": "supercharging_dart/numeric_computing.html",
    "title": "21  Numeric Computing",
    "section": "",
    "text": "22 Chapter: Numeric Computing in Dart - The Celestial Harmony\nWelcome, future space explorers! In this chapter, we will journey across the cosmic plains of numeric computing in Dart. With the dart:math library as our spaceship, we’ll uncover the mysteries of the universe and the harmonic symphony it plays."
  },
  {
    "objectID": "supercharging_dart/numeric_computing.html#the-basics-cosmic-constants-and-astronomical-arithmetic",
    "href": "supercharging_dart/numeric_computing.html#the-basics-cosmic-constants-and-astronomical-arithmetic",
    "title": "21  Numeric Computing",
    "section": "22.1 The Basics: Cosmic Constants and Astronomical Arithmetic",
    "text": "22.1 The Basics: Cosmic Constants and Astronomical Arithmetic\nimport 'dart:math' as math;\n\nvoid main() {\n  print('Pi: ${math.pi}');\n  print('Euler\\\\'s number: ${math.e}');\n  print('Golden ratio: ${(1 + math.sqrt(5)) / 2}');\n}\nOur universe dances to the tunes of some significant constants. Pi, the ratio of a circle’s circumference to its diameter, and Euler’s number, the base of natural logarithms, are the melodies that govern the elliptical orbits of planets around stars. The golden ratio? It’s everywhere, from spiral galaxies to the arrangement of sunflower seeds!"
  },
  {
    "objectID": "supercharging_dart/numeric_computing.html#spherical-trigonometry-a-harmonious-trio-of-sin-cos-and-tan",
    "href": "supercharging_dart/numeric_computing.html#spherical-trigonometry-a-harmonious-trio-of-sin-cos-and-tan",
    "title": "21  Numeric Computing",
    "section": "22.2 Spherical Trigonometry: A Harmonious Trio of Sin, Cos, and Tan",
    "text": "22.2 Spherical Trigonometry: A Harmonious Trio of Sin, Cos, and Tan\ndouble radianToDegree(double radian) =&gt; radian * (180 / math.pi);\n\nvoid main() {\n  double angle = 60; // Let's say the angle is 60 degrees\n\n  double angleInRadians = math.radians(angle); // Convert it to radians\n\n  print('Sin(60): ${math.sin(angleInRadians)}'); // 0.86602540378\n  print('Cos(60): ${math.cos(angleInRadians)}'); // 0.5\n  print('Tan(60): ${math.tan(angleInRadians)}'); // 1.73205080757\n}\nThe universe’s orchestra plays in the language of trigonometry. When mapping the night sky or calculating the path of a comet, sin, cos, and tan help us describe the universe’s spherical geometry. They’re the basis of our cosmic sheet music."
  },
  {
    "objectID": "supercharging_dart/numeric_computing.html#celestial-harmonics-power-and-logarithms",
    "href": "supercharging_dart/numeric_computing.html#celestial-harmonics-power-and-logarithms",
    "title": "21  Numeric Computing",
    "section": "22.3 3. Celestial Harmonics: Power and Logarithms",
    "text": "22.3 3. Celestial Harmonics: Power and Logarithms\nvoid main() {\n  print('2^10: ${math.pow(2, 10)}'); // 1024.0\n  print('Log(100): ${math.log(100)}'); // 4.605170185988092\n}\nEver wonder why star brightness is measured on a logarithmic scale? It’s because the energy they produce, seen as light, is enormously varied. By using logarithms, we can make sense of this vast spectrum. As for pow, well, it’s how we calculate the incredible energies involved when stars go supernova!"
  },
  {
    "objectID": "supercharging_dart/numeric_computing.html#random-constellations-darts-random-class",
    "href": "supercharging_dart/numeric_computing.html#random-constellations-darts-random-class",
    "title": "21  Numeric Computing",
    "section": "22.4 4. Random Constellations: Dart’s Random Class",
    "text": "22.4 4. Random Constellations: Dart’s Random Class\nvoid main() {\n  var rng = math.Random();\n  for (var i = 0; i &lt; 10; i++) {\n    print(rng.nextInt(100)); // Generate a random integer between 0 and 99\n  }\n}\nJust like how we discover unexpected patterns in the night sky, Dart’s Random class adds an element of surprise to our code. Remember, while the universe might seem chaotic, there’s always an underlying pattern or principle — a hidden harmony."
  },
  {
    "objectID": "supercharging_dart/numeric_computing.html#for-all-humanity",
    "href": "supercharging_dart/numeric_computing.html#for-all-humanity",
    "title": "21  Numeric Computing",
    "section": "22.5 For all humanity",
    "text": "22.5 For all humanity\nWhether you’re calculating the gravitational interaction of galaxies or plotting the lifecycle of a star, Dart’s numeric computing capabilities and the dart:math library are like your scientific calculators. Just remember, every time you crunch a number, you’re playing a note in the grand symphony of the universe. So, don’t just code. Compose! Create your cosmic concerto with Dart and uncover the hidden harmonies in the cosmos."
  },
  {
    "objectID": "supercharging_dart/organizing_your_code.html",
    "href": "supercharging_dart/organizing_your_code.html",
    "title": "22  Organizing Your Code",
    "section": "",
    "text": "Organizing Your Space(ship): A Journey in Code Cleanliness\n\nChapter: Organizing Your Space(ship): A Journey in Code Cleanliness\nImagine this: You’re the proud pilot of a state-of-the-art spaceship, bristling with impressive technology, darting through the interstellar vastness. Now, remember that this spaceship is not just a means of transport. It’s your home, your lab, and your workstation, all at the same time. It’s a lot like your code. Each part of your ship needs to be carefully organized, otherwise, you’d be floating in a mess of loose nuts, bolts, and ill-placed astronaut ice-cream!\n1. The Toolshed (Variables and Functions)\nStarting off, your spaceship has a toolshed where you store all your nifty tools, just like the variables in your code. You wouldn’t leave your hyper-wrench floating around the ship, would you? Likewise, it’s best to keep your variables confined to the part of the code where they’re needed. If a variable is used only inside a function, don’t let it float freely in the spaceship; keep it safe and organized inside the function!\n2. The Control Room (Control Structures)\nThe control room is the heart of your spaceship, where you pilot your vessel. Like if-else statements and loops, each button and lever in the control room serves a specific purpose. Just as you’d group related controls together (say, navigation on one panel, life-support on another), it’s important to keep related pieces of logic together in your code. Grouping related logic makes your code easier to navigate and understand.\n3. Living Quarters (Objects and Classes)\nThe living quarters are where the crew lives and works, much like objects in your code. Each room is designed for a specific person with all the amenities they need - just like a class in your code, designed for a specific purpose with all the variables and methods it needs. This organization helps avoid clutter and confusion.\n4. The Engine Room (Modules and Libraries)\nThe engine room is filled with heavy-duty machinery, powering your spaceship, much like the libraries and modules in your code. Each machine performs a specific function. Instead of letting these machines sprawl all over the spaceship, you keep them in the engine room, right? Similarly, keep your code that performs specific tasks within its own module or library.\n5. The Logbook (Comments)\nFinally, the ship’s logbook is an essential tool to remember what each switch does or what each part of the ship is for. It’s a lot like comments in your code. Proper commenting is like leaving a clean logbook for the next shift or even for future-you! Remember, the most confusing code is code that you wrote six months ago.\nOrganizing your spaceship, much like organizing your code, is a vital part of being an interstellar explorer or a stellar programmer. Having a well-organized ship/codebase will make your journey more enjoyable and less of a stellar headache!"
  },
  {
    "objectID": "object_oriented_programming.html#design-patterns",
    "href": "object_oriented_programming.html#design-patterns",
    "title": "23  Object-Oriented Programming",
    "section": "23.1 Design patterns",
    "text": "23.1 Design patterns\nThe Superpowers of our League\n\nDesign patterns are just like the special abilities of our superheroes - tried and true techniques that come in handy when faced with recurring coding challenges. They are templates or blueprints that can be reused in many different situations. Let’s take a look at a few.\n\n23.1.1 Singleton: The Immortal One\nThis pattern restricts a class from instantiating multiple objects. There’s only one instance of this class across your application, much like there’s only one Immortal One!\nclass Singleton {\n  static final Singleton _singleton = Singleton._internal();\n\n  factory Singleton() {\n    return _singleton;\n  }\n\n  Singleton._internal();\n}\n\nvoid main() {\n  var s1 = Singleton();\n  var s2 = Singleton();\n\n  print(identical(s1, s2));  // prints: true\n}\n\nHere, the Singleton class has a private constructor, which means no other class can instantiate it. When we call Singleton(), we get the same instance every time, thus ensuring the immortality of the singleton object.\n\n\n23.1.2 Factory: The Shapeshifter\nFactory pattern is about creating objects without specifying the exact class of object that will be created, just like the Shapeshifter can morph into anything!\nabstract class Shape {\n  void draw();\n}\n\nclass Circle implements Shape {\n  void draw() {\n    print('Drawing a circle');\n  }\n}\n\nclass Square implements Shape {\n  void draw() {\n    print('Drawing a square');\n  }\n}\n\nShape shapeFactory(String type) {\n  if (type == 'circle') return Circle();\n  if (type == 'square') return Square();\n  throw 'Can\\\\'t create $type';\n}\n\nvoid main() {\n  var circle = shapeFactory('circle');\n  circle.draw(); // prints: Drawing a circle\n\n  var square = shapeFactory('square');\n  square.draw(); // prints: Drawing a square\n}\n\nHere, shapeFactory returns a Shape object but the actual type is hidden from the client, allowing the Shapeshifter to transform into a Circle or Square.\n\n\n23.1.3 Observer: The Mind Reader\nThis pattern allows an object (the observer) to watch another object (the subject), and be notified when the subject changes state. Just like the Mind Reader is always in the know!\nclass Subject {\n  List&lt;Observer&gt; observers = [];\n\n  void addObserver(Observer observer) {\n    observers.add(observer);\n  }\n\n  void notify(String message) {\n    for(var observer in observers) {\n      observer.update(message);\n    }\n  }\n}\n\nclass Observer {\n  void update(String message) {\n    print('Received: $message');\n  }\n}\n\nvoid main() {\n  var subject = Subject();\n  var observer1 = Observer();\n  var observer2 = Observer();\n\n  subject.addObserver(observer1);\n  subject.addObserver(observer2);\n\n  subject.notify('Something happened!');\n}\n\nHere, Observer classes get notified when the Subject calls notify(), keeping them up to date with the latest happenings. That’s Mind Reader for you!\nWith these design patterns in your superhero toolkit, you’re ready to face even the most villainous coding challenges head-on. Remember, with great power comes great responsibility, so use them wisely!"
  },
  {
    "objectID": "object_oriented_programming.html#mixins",
    "href": "object_oriented_programming.html#mixins",
    "title": "23  Object-Oriented Programming",
    "section": "23.2 Mixins",
    "text": "23.2 Mixins\nWhile we covered composition briefly in our chapter on object-oriented programming, there is a more conventional way of mixing and matching new combinations of code called Mixins.\nMixins are a way of reusing a class’s code in multiple class hierarchies. Think of it as a magical tome of spells that any wizard can use, regardless of their school of magic. Here’s an example:\nmixin Agility {\n  void dodge() {\n    print(\"Dodged the attack!\");\n  }\n}\n\nclass Player {\n  void attack() {\n    print(\"Attack!\");\n  }\n}\n\nclass Rogue extends Player with Agility { }\n\nvoid main() {\n  var rogue = Rogue();\n  rogue.attack();\n  rogue.dodge();\n}\nIn this code, the Rogue class has all the methods of the Player class and also the Agility mixin."
  },
  {
    "objectID": "object_oriented_programming.html#generics",
    "href": "object_oriented_programming.html#generics",
    "title": "23  Object-Oriented Programming",
    "section": "23.3 Generics",
    "text": "23.3 Generics\nGenerics are a way of writing flexible, reusable code that works with different data types. They’re like a magical key that can open any lock in our game! Here’s a simple example:\nclass TreasureBox&lt;T&gt; {\n  T content;\n\n  TreasureBox(this.content);\n\n  void open() {\n    print(\"You've found $content!\");\n  }\n}\n\nvoid main() {\n  var goldBox = TreasureBox&lt;int&gt;(500);\n  goldBox.open(); // You've found 500!\n\n  var gemBox = TreasureBox&lt;String&gt;('a rare gem');\n  gemBox.open(); // You've found a rare gem!\n}\nIn this example, TreasureBox is a generic class that can contain any type of content. T is a placeholder that you replace with the actual type when you create an instance of TreasureBox.\nThese are some of the advanced topics in Dart. Each of these topics can be a chapter in itself. Understanding these advanced features of Dart can make your code more robust, flexible, and efficient. As you continue your journey into Dart programming, be sure to explore each of these topics in more depth!"
  },
  {
    "objectID": "object_oriented_programming.html#lets-wrap-this-up",
    "href": "object_oriented_programming.html#lets-wrap-this-up",
    "title": "23  Object-Oriented Programming",
    "section": "23.4 Let’s wrap this up!",
    "text": "23.4 Let’s wrap this up!\nSo, just like how every superhero adds value to the Avengers, every concept in OOP is crucial in programming. And remember, with great coding power comes great bug-fixing responsibility! Next up, we’ll be exploring the cosmic realms of Asynchronous Programming. Stay tuned!"
  },
  {
    "objectID": "advanced_dart.html",
    "href": "advanced_dart.html",
    "title": "24  Advanced Dart",
    "section": "",
    "text": "The following advanced topics will commonly be encountered in the first years of programming. Each concept is given a corresponding sub-chapter since they have many details. We keep the chapters short, however, so the reader will have a basic understanding of each concept.\nError Handling\nCascade Notion Operator\nIsolates\nMetaprogramming\nExtension Methods\nEnumerated Types\nSound Null Safety\nHashing\nRecords, Patterns, and Pattern Matching\nWrapping Up"
  },
  {
    "objectID": "advanced_dart/error_handling.html#error-handling-beyond-the-basics",
    "href": "advanced_dart/error_handling.html#error-handling-beyond-the-basics",
    "title": "25  Error Handling",
    "section": "25.1 Error Handling: Beyond the Basics",
    "text": "25.1 Error Handling: Beyond the Basics\nIn our Dart programming journey, we might stumble upon more complicated issues, like difficult and unexpected traps in our treasure hunt. Let’s equip ourselves with more advanced error-handling tools!\n\n25.1.1 Custom Exceptions\nIn Dart, we can create our own custom exceptions to represent specific error conditions. Let’s say, for instance, you’re trying to open a treasure chest, but it’s locked. In the programming world, this could be a “ChestLockedException”. Let’s see how we could create and use this custom exception:\nclass ChestLockedException implements Exception {\n  String cause = \"The chest is locked!\";\n}\n\nvoid main() {\n  try {\n    throw ChestLockedException();\n  } catch(error) {\n    print(error.cause); // Will output: The chest is locked!\n  }\n}\nHere’s what’s happening in this code:\n\nWe define a class ChestLockedException that implements the Exception interface. This class has a string field cause that contains the message “The chest is locked!”.\nIn the main function, we use a try-catch block to throw and catch this exception. Inside the try block, we throw a new instance of ChestLockedException.\nThe catch block then catches the thrown exception. Since we know that our exception has a cause field, we can access it using error.cause and print it out.\n\nSo, in plain language: we are simulating a scenario where we’re trying to open a locked chest. As we expect, an error occurs (the chest is locked), so we throw a specific ChestLockedException. We then catch this exception and print out the reason the error occurred (the chest is locked).\n\n\n25.1.2 Stack Traces\nWhen an error occurs, Dart gives you a stack trace, which is like a breadcrumb trail leading back to the origin of the error. This helps you track down the source of the error and fix it. Here’s how you might see it:\nvoid functionThatThrows() {\n  throw Exception('This is an exception');\n}\n\nvoid main() {\n  try {\n    functionThatThrows();\n  } catch(error, stackTrace) {\n    print(error);\n    print(stackTrace);\n  }\n}\nIn the code above, stackTrace is a StackTrace object that you can print out to see the sequence of method calls leading to the exception.\nHere’s a hypothetical example of what the stackTrace could look like:\nException: This is an exception\n#0      functionThatThrows (...dart_project/main.dart:2:3)\n#1      main (...dart_project/main.dart:7:5)\n#2      _startIsolate.&lt;anonymous closure&gt; (dart:isolate-patch/isolate_patch.dart:309:32)\n#3      _RawReceivePortImpl._handleMessage (dart:isolate-patch/isolate_patch.dart:184:12)\nThe output of the stackTrace starts with the most recent method call (the source of the exception) and follows the path of execution back to the first method call.\nEach line of the stackTrace typically includes:\n\nThe index of the stack frame (starting with 0),\nThe name of the method that was called,\nThe path to the file where the method was defined,\nThe line number and column where the method was called in that file.\n\nIn this case, the functionThatThrows (which is in your main.dart file on line 2, column 3) is the first method listed because it’s where the exception was thrown. The following line is the main method (also in your main.dart file, but on line 7, column 5), which is where functionThatThrows was called. The last two lines are part of Dart’s internal workings and show the steps Dart took to start your program.\nThis kind of traceback is incredibly useful in debugging because it tells you where the error occurred and how the program got there.\nNext:\nCascade Notion Operator"
  },
  {
    "objectID": "advanced_dart/cascade_notion_operator.html",
    "href": "advanced_dart/cascade_notion_operator.html",
    "title": "26  Cascade Notion Operator",
    "section": "",
    "text": "26.0.1 Cascade Notation Operator\nIt’s time to meet one of Dart’s handy wizards - the Cascade Notation Operator (..). This operator might seem like just two little dots, but don’t let that fool you - it has a mighty power in Dart.\nThe Cascade Notation Operator allows you to perform a series of operations on a single object. It’s like having a magical multitasking wand that can quickly perform several spells on the same item.\nLet’s imagine we’re organizing a grand feast for all the brilliant programmers across the globe, and we’re using a fabulous recipe app we’ve created using Dart. Let’s add a few tasks to our recipe with the cascade operator.\nclass Recipe {\n  String name = '';\n  List&lt;String&gt; ingredients = [];\n  List&lt;String&gt; steps = [];\n\n  void showRecipe() {\n    print('Recipe: $name');\n    print('Ingredients: $ingredients');\n    print('Steps: $steps');\n  }\n}\n\nvoid main() {\n  var feast = Recipe()\n    ..name = 'Global Programmer\\'s Feast'\n    ..ingredients.addAll(['Code snippets', 'A dash of creativity', 'Cupfuls of inclusivity'])\n    ..steps.addAll(['Mix well', 'Compile without errors', 'Serve hot with a side of fun'])\n    ..showRecipe();\n}\nIsn’t that neat? The cascade operator (..) allows us to call multiple methods or set multiple properties on our Recipe object, all in one go, without needing to reference the feast variable multiple times. It’s like our code is multitasking! With the cascade operator, we’re not just preparing a feast - we’re serving a masterclass in efficiency.\nThat’s the power of Dart’s Cascade Notation Operator. It’s all about performing many tasks in a neat, streamlined manner. It’s like having a team of magical sous chefs all working in perfect harmony to prepare the ultimate coding cuisine. Bon appétit!\nTake time for quiet contemplation in:\nIsolates"
  },
  {
    "objectID": "advanced_dart/isolates.html",
    "href": "advanced_dart/isolates.html",
    "title": "27  Isolates",
    "section": "",
    "text": "In the realm of Dart, each bit of code resides within an ‘Isolate’, an entity that is, quite aptly, isolated from all others. These Isolates don’t share memory. It’s as if each one is a different planet in our Dart galaxy, each having its own atmosphere (memory) and life-forms (code).\nvoid broadcastMessage(String message) {\n  print(message);\n}\n\nvoid main() {\n  Isolate.spawn(broadcastMessage, 'Greetings from Planet Dart!');\n}\nIn the stellar code above, Isolate.spawn forms a new planet (creates a new isolate) and broadcasts the broadcastMessage signal from that planet (runs the function in that isolate). The second argument to Isolate.spawn is the interstellar message transmitted to the new planet (isolate).\nThink of it this way: You’re creating a new planet and then broadcasting an interstellar message: ‘Greetings from Planet Dart!’.\nAnd the cool part? Each planet (isolate) exists in its own corner of the galaxy, unaffected by any cosmic disasters (errors) that might befall its neighbors. Isn’t it fascinating? Welcome to the cosmic journey of Dart Isolates!\nBe more meta with:\nMetaprogramming"
  },
  {
    "objectID": "advanced_dart/metaprogramming.html",
    "href": "advanced_dart/metaprogramming.html",
    "title": "28  Metaprogramming",
    "section": "",
    "text": "Alright, let’s board the Hogwarts Express and delve into the meta-magical world of Dart metaprogramming!\nIn the mystic world of Dart, the @ character is our wand to cast annotations, a potent charm to attach magical properties (metadata) to parts of your incantations (code). The magicSpell you see in your code is an annotation - a magical spell you cast on your code.\nThese annotations can be wielded by wizarding tools and enchanted libraries to transform the way the incantations are processed or interpreted. For instance, some spells (annotations) might be used to conjure additional code, provide hints to the all-knowing prophecy orbs (static analysis tools), or alter the code’s behavior in the runtime realm.\nTo cast the magicSpell, it must be summoned from the depths of your code. This might look like a simple incantation like this:\nclass magicSpell {\n  const magicSpell();\n}\nIn this example, magicSpell is a magical class with a single spell-casting command (constructor) that takes no magical ingredients (arguments). This is a common pattern for annotations. You can think of magicSpell as a magical badge that we’re placing on another spell (function).\nFor example, when you use @magicSpell above doSomething, you apply that magical badge to the doSomething spell.\n@magicSpell\nvoid doSomething() {\n  // Do something magical...\n}\nAt this point, the magicSpell annotation is just a magical badge that does nothing itself. But other spells—like a metaprogramming tool or enchanted library—could read your incantations, discover the magicSpell annotation, and do something magical with the doSomething function because of it. That magic could be anything from conjuring additional code to modifying the function’s behavior in the runtime realm.\nIt’s like walking into a potions class, where the outcome can be as surprising as it is magical! Welcome to the wondrous journey of Dart metaprogramming!\nExtend your capabilities with:\nExtension Methods"
  },
  {
    "objectID": "advanced_dart/extension_methods.html",
    "href": "advanced_dart/extension_methods.html",
    "title": "29  Extension Methods",
    "section": "",
    "text": "Alright, let’s spin this with a dance party theme! Extension methods are like adding new dance moves and expression to your repertoire - you’re expanding your abilities, and adding a spark to the dance floor.\nextension on String {\n  String addSomeEnthusiasm() =&gt; toUpperCase() + '!!!';\n}\n\nvoid main() {\n  print('let us dance'.addSomeEnthusiasm()); // LET US DANCE!!!\n}\n\nIn the above code, we’re busting out a new move, addSomeEnthusiasm, on the String class. Now, every string can add enthusiasm to the dance floor by converting the string to upper case and adding three exclamation marks - making your statements loud, proud, and dance-ready!\nThink of extension methods as learning a new dance style to spice up your routine. You’re not changing the fundamental steps - walking is still walking, and a String is still a String - but you’re adding some flair to your execution. So get ready to shake things up and make the code dance to your rhythm with extension methods!\nAllow specific values with:\nEnumerated Types"
  },
  {
    "objectID": "advanced_dart/enumerated_types.html",
    "href": "advanced_dart/enumerated_types.html",
    "title": "30  Enumerated Types",
    "section": "",
    "text": "Enumerated types, also known as enums, are a special type of class in Dart used to represent a fixed number of simple values. Enums are incredibly useful when describing a value that can only take one out of a small set of possible values.\nImagine you’re writing a program that deals with the days of the week. Sure, you could represent the days of the week as strings or integers. Still, then you’d constantly have to remember whether “Monday” is represented by “1” or “0”, and there’s a risk of accidentally assigning “8” to a variable that represents a day. Here’s where enums come in.\nenum DaysOfTheWeek {\n  Monday,\n  Tuesday,\n  Wednesday,\n  Thursday,\n  Friday,\n  Saturday,\n  Sunday,\n}\nWith this enum definition, you can now create variables that can only hold a valid day of the week:\nDaysOfTheWeek today = DaysOfTheWeek.Monday;\nDart will prevent you from assigning any other value to today. This way, we avoid the risk of typo errors and make the code safer and easier to read. Enums improve code clarity and prevent errors by ensuring that variables can only take one of a fixed set of values.\nNote that the enum’s values (like DaysOfTheWeek.Monday) are full-fledged objects in their own right, with a index property that gets automatically assigned based on their position (starting from 0):\nprint(DaysOfTheWeek.Monday.index); // Output: 0\nprint(DaysOfTheWeek.Friday.index); // Output: 4\nYou can also retrieve a list of all the values in an enum using the values property:\nprint(DaysOfTheWeek.values); \n// Output: [DaysOfTheWeek.Monday, DaysOfTheWeek.Tuesday, DaysOfTheWeek.Wednesday, DaysOfTheWeek.Thursday, DaysOfTheWeek.Friday, DaysOfTheWeek.Saturday, DaysOfTheWeek.Sunday]\nThis can be useful for situations where you need to loop over all possible values of an enum.\nAnd that’s an introduction to enumerated types in Dart! As you can see, they’re a simple yet powerful feature that can make your code safer and easier to understand.\nAvoid interstellar surprises with:\nSound Null Safety"
  },
  {
    "objectID": "advanced_dart/sound_null_safety.html",
    "href": "advanced_dart/sound_null_safety.html",
    "title": "31  Sound Null Safety",
    "section": "",
    "text": "Let’s hop on an intergalactic adventure.\n\nIn the infinite expanse of the coding universe, a lurking danger often disrupts the peace of coding civilizations: the infamous NullReferenceException, also known as the “Billion-Dollar Mistake.” This shady character is known to make programs implode, causing catastrophic system failures.\nBut fear not! In the high-tech world of Dart, the Coding Council came up with a mighty force field known as Sound Null Safety. This innovative force field protected the world’s code, ensuring that no variable could contain a null, a vacuum in this case unless the coder declared it explicitly.\nint energyLevel = null; // Alert! A variable of type 'int' can't be assigned null.\nint? fuelLevel = null; // This is acceptable; fuellevel can contain null (or vacuum) because of the '?'.\nIn this scenario, the variable energyLevel is like a spaceship refusing to accept a vacuum in its energy core. But fuelLevel is designed to handle a vacuum because of the ‘?’ symbol, making it a more versatile spacecraft.\nSound Null Safety is like the advanced AI system on a spaceship, it ensures that all variables act like vacuum-resistant spaceships unless told otherwise by the ‘?’ symbol.\nBut what happens when you need to use a variable that could potentially be a vacuum? The Coding Council had foreseen this too. You are required to “check” the vacuum. Imagine it as a protective mechanism on the spaceship, allowing operations only if they’re not going to create a vacuum:\nint? potentialVacuum = null;\nint guaranteedFuel = potentialVacuum ?? 0; // If potentialVacuum is null (or a vacuum), then use 0.\nThanks to Sound Null Safety, the coding universe of Dart is well-protected against the disruptive effects of the NullReferenceException. This has made coding exploration much safer and has ensured continued prosperity and progress in the world of Dart!\nRemember, fellow space explorer, during your journey through the code cosmos, Sound Null Safety is your trusty AI guide, steering you clear of the dangerous vacuum of nulls!\nHash things out with:\nHashing"
  },
  {
    "objectID": "advanced_dart/hashing.html",
    "href": "advanced_dart/hashing.html",
    "title": "32  Hashing",
    "section": "",
    "text": "33 Chapter: The Magic Bakery: An Adventure in Hashing with Dart\n“Step into the magic bakery of Dart, where each sumptuous treat is more unique than the last, just like our hashing concept. What’s that? You’ve never heard of ‘hashing’ in a bakery? Oh, my friend, you’re in for a delightful surprise! Welcome to the world where computer science meets the irresistible aroma of baked goodies!”"
  },
  {
    "objectID": "advanced_dart/hashing.html#what-is-hashing",
    "href": "advanced_dart/hashing.html#what-is-hashing",
    "title": "32  Hashing",
    "section": "33.1 1. What is Hashing?",
    "text": "33.1 1. What is Hashing?\nImagine you walk into a bakery filled with mouthwatering pastries. But here’s the thing - each pastry is one of a kind. How do we distinguish them all? Easy! The magic baker uses a special technique: each pastry is sprinkled with a unique mix of magic sugar that assigns a unique number, known as a ‘hash code’. Just like our pastries, objects in Dart can have their own hash code too.\nvoid main() {\n  var cupcake = 'Strawberry Cupcake';\n  print(cupcake.hashCode);  // Outputs a unique number, the hash code of 'Strawberry Cupcake'\n}\nHere, hashCode is like our magic sugar sprinkler, creating a unique hash code for the Strawberry Cupcake."
  },
  {
    "objectID": "advanced_dart/hashing.html#why-is-hashing-important",
    "href": "advanced_dart/hashing.html#why-is-hashing-important",
    "title": "32  Hashing",
    "section": "33.2 2. Why is Hashing Important?",
    "text": "33.2 2. Why is Hashing Important?\nBack in our bakery, imagine you have hundreds of unique pastries. You need to find a specific one - a delectable Lemon Tart. How would you find it amongst all these treats without tasting each one? The answer is the magic sugar, or hash code! It helps to quickly find and identify our Lemon Tart. Similarly, in programming, hashing helps us locate and access data swiftly and efficiently.\nvoid main() {\n  var magicBakery = { 'Strawberry Cupcake'.hashCode : 'Strawberry Cupcake', 'Lemon Tart'.hashCode : 'Lemon Tart' };\n  var desiredTreatHashCode = 'Lemon Tart'.hashCode;\n  print(magicBakery[desiredTreatHashCode]); // Outputs 'Lemon Tart'\n}\nIn the code above, magicBakery is our Dart map, acting as the bakery catalogue. Each pastry is associated with its unique hash code. To find the Lemon Tart, we just look for its hash code!"
  },
  {
    "objectID": "advanced_dart/hashing.html#collision-course---when-two-treats-share-the-same-magic-sugar",
    "href": "advanced_dart/hashing.html#collision-course---when-two-treats-share-the-same-magic-sugar",
    "title": "32  Hashing",
    "section": "33.3 3. Collision Course - When Two Treats Share the Same Magic Sugar",
    "text": "33.3 3. Collision Course - When Two Treats Share the Same Magic Sugar\nIn a perfect bakery, each treat would have its own unique magic sugar. But sometimes, two treats end up with the same hash code - we call this a ‘collision’. Fear not! Our wise baker always has a solution. He simply adds a tiny detail to the magic sugar mixture to make it unique again!\nclass Pastry {\n  String name;\n  String flavor;\n\n  // Constructor\n  Pastry(this.name, this.flavor);\n\n  // Custom hashcode\n  @override\n  int get hashCode =&gt; name.hashCode ^ flavor.hashCode;\n}\nIn this code, our Pastry class represents a unique pastry. In the rare case of a collision, we define a custom hash code. It combines the hash codes of name and flavor using the bitwise XOR operator (^), ensuring our hash code stays unique.\nAh, the magical world of hashing in Dart! A delightful blend of uniqueness and efficiency, much like our magical bakery. Remember, just as every delicious pastry can be found by its magic sugar, so too can every object be efficiently accessed by its hash code. Happy baking, my friend!\nDefine and identify new structures with:\nRecords, Patterns, and Pattern Matching"
  },
  {
    "objectID": "advanced_dart/records_patterns_and_pattern_matching.html",
    "href": "advanced_dart/records_patterns_and_pattern_matching.html",
    "title": "33  Records, Patterns, and Pattern Matching",
    "section": "",
    "text": "Dart 3 introduces some exciting new gameplay elements: Records, Patterns, and Pattern Matching. As of my knowledge cutoff in September 2021, specific information on these features in Dart is not available. However, let’s have a sneak peek at what these could mean based on similar features in other languages…\nI’m sorry, but it seems that I’m currently experiencing difficulties accessing real-time online information. I can still assist you by drawing upon my existing knowledge base, which is current up until September 2021.\nRecords, Patterns, and Pattern Matching are common in some other programming languages like C# and Python, and can be used to simplify code and make it more readable.\nHowever, I can provide you with some general understanding of these features and how they might be used in a programming language:\n\nRecords: In some languages, a record is a composite data type that groups related fields of information together. It can be thought of as a more structured version of a class in object-oriented programming. For example, a Person record might include fields for name, age, and address.\nPatterns: In programming, a pattern can be a way to match and extract information from data. A common example is a regular expression, which can match patterns in text. Pattern matching can be used in conjunction with data types like records to extract information.\nPattern Matching: This is a feature in some programming languages that allows you to check a given sequence of tokens for the presence of the constituents of some pattern. In essence, pattern matching allows you to test a variable against a variety of forms and extract information from it if it matches the form.\n\nIn the context of Dart, you might use these features to create more expressive, succinct code.\nFor example, consider the following pseudocode:\nrecord Person(String name, int age, String address);\n\nPerson bob = Person(\"Bob\", 30, \"123 Elm St\");\n\nmatch (bob) {\n  case Person(name, age, _) =&gt; print(\"$name is $age years old.\");\n  default =&gt; print(\"Unknown person\");\n}\nIn this code, we define a Person record with fields for name, age, and address. We then create a Person named bob. The match statement is an example of pattern matching: it checks bob against a series of patterns. In this case, the pattern is a Person with any name, any age, and any address (indicated by _). If bob matches this pattern, it prints a statement with his name and age.\nPlease note that this is pseudocode and will not run in actual Dart as of my knowledge cutoff in September 2021. I would recommend checking the latest Dart documentation for the most accurate and up-to-date information.\nWith each of these advanced Dart features, our game of coding becomes more engaging, powerful, and fun. Let’s dive in to find out more about these superpowers at our disposal!\nNow that you are much more advanced:\nWrapping Up"
  },
  {
    "objectID": "advanced_dart/wrapping_up.html",
    "href": "advanced_dart/wrapping_up.html",
    "title": "34  Wrapping Up",
    "section": "",
    "text": "35 Wrapping up\nIn this chapter, we’ve delved deep into the realm of advanced Dart. We’ve covered a broad range of topics, exploring areas that make Dart a versatile and powerful language. Here’s a quick recap of our thrilling journey:\n\nAdvanced Error Handling: We learned how to handle complex errors using custom exceptions and stack traces, ensuring that our programs behave predictably even when things go wrong.\nMixins: We discovered the power of mixins, allowing us to reuse and combine code in an incredibly flexible way.\nGenerics: We peeked into the world of generics, a mechanism that allows us to write code that can work with different types while preserving type safety.\nCollections: We studied more advanced usage of Dart’s collection classes, including Map, Set, and Queue.\nAdvanced Asynchronous Programming: We deepened our understanding of Dart’s Future and Stream classes, exploring how to handle errors and cancellation in asynchronous code.\nIsolates: We were introduced to Dart’s model for concurrent programming.\nMetaprogramming: We scratched the surface of metaprogramming, understanding how Dart supports code that generates or analyzes other code.\nExtension Methods: We learned how to add new functionality to existing classes without having to modify them.\nEnumerated Types (Enums): We explored enums, a special kind of class used to represent a fixed number of simple values.\nSound Null Safety: We delved into the safety features of Dart that prevent null reference exceptions.\nNumeric Computing: We glanced at Dart’s capabilities in performing mathematical and numerical operations.\nRegular Expressions: We glimpsed the power of regular expressions, a tool for matching patterns in strings.\nHashing: We touched upon Dart’s utilities for creating hash codes, a fundamental concept in data structures.\nRecords, Patterns, and Pattern Matching: We briefly discussed these advanced features of Dart that open up new paradigms for handling data and flow in our applications.\n\nIn each section, we armed ourselves with code snippets, relatable examples, and easy-to-understand analogies, gradually demystifying the complex topics of advanced Dart programming.\nAnd with that, we wrap up this enlightening chapter on Advanced Dart. Each of these topics is a book unto itself, so don’t worry if you’re not a master of them all yet. The aim of this chapter was to give you a broad overview, and inspire you to dive deeper into the areas that intrigue you most.\nKeep practicing, keep learning, and remember – every expert was once a beginner. The magic happens one line of code at a time. Onward to the next adventure!\nBuild with confidence by:\nTesting your Dart Code"
  },
  {
    "objectID": "testing_dart_code.html#introduction-to-testing",
    "href": "testing_dart_code.html#introduction-to-testing",
    "title": "35  Testing your Dart Code",
    "section": "35.1 Introduction to Testing",
    "text": "35.1 Introduction to Testing\nImagine, if you will, that you’re not just a junior software engineer at a prestigious space agency, but you’ve become the custodian of the code that keeps an actual spaceship flying. Now that’s a lot of responsibility resting on your shoulders! Remember, in space, no one can hear you scream, “I should have tested my code!”\n\n35.1.1 The Importance of Testing\nTesting your code is like the pre-flight checks performed before a rocket launch. You wouldn’t want to discover a critical failure after the launch, would you? That would be a quick ticket to Unemploymentville rather than to Mars!\n\n\n35.1.2 Types of Testing\nWe have different types of testing like unit testing, integration testing, and system testing. Think of them as checking the spaceship’s engines, making sure the crew’s life support systems work together, and finally testing the whole spaceship."
  },
  {
    "objectID": "testing_dart_code.html#unit-testing",
    "href": "testing_dart_code.html#unit-testing",
    "title": "35  Testing your Dart Code",
    "section": "35.2 Unit Testing",
    "text": "35.2 Unit Testing\n\n35.2.1 Introduction to Unit Testing\nUnit tests are the nuts and bolts of your spaceship, the individual parts you check before putting everything together. It’s like testing a single thruster before attaching it to the spaceship.\n\n\n35.2.2 Anatomy of a Unit Test\nA unit test usually has three parts: Arrange, Act, Assert. It’s like preparing your space helmet (Arrange), putting it on (Act), and checking if the oxygen flows correctly (Assert).\nvoid main() {\n  // Arrange\n  var helmet = SpaceHelmet();\n\n  // Act\n  helmet.putOn();\n\n  // Assert\n  expect(helmet.oxygenFlow, isTrue);\n}\n\n\n\n35.2.3 Writing Your First Unit Test\nOur first unit test will be to check if the spaceship’s thruster works as expected.\nimport 'package:test/test.dart';\nimport 'package:spaceMission/thruster.dart';\n\nvoid main() {\n  test('Check Thruster', () {\n    // Arrange\n    var thruster = Thruster();\n\n    // Act\n    var thrustPower = thruster.fire();\n\n    // Assert\n    expect(thrustPower, equals(1000));\n  });\n}\n\nIn this code, we’re creating a Thruster, firing it, and then checking if the thrust power is as expected.\n\n\n35.2.4 Testing Edge Cases\nTesting edge cases is like checking if the spaceship can handle an unexpected asteroid storm or the crew can survive on backup oxygen for a week. These are unusual, but they could happen!\nvoid main() {\n  test('Thruster fires even if fuel is low', () {\n    // Arrange\n    var thruster = Thruster();\n    thruster.fuel = 1;\n\n    // Act\n    var thrustPower = thruster.fire();\n\n    // Assert\n    expect(thrustPower, isNot(0));\n  });\n}\n\nIn this test, we’re making sure that even with low fuel, the thruster still fires. It might not give the full thrust power, but it shouldn’t be zero either.\nAnd that’s a wrap for unit testing! Just remember, these are your front-line soldiers in the battle against bugs.\n[… to be continued …]\nNote: Testing is not just a technical task, it’s a way of life! Well, at least for us software engineers. And let’s be honest, if you were the one on a spaceship built by your code, you’d want it tested to oblivion and back, right?"
  },
  {
    "objectID": "data_management.html#mystery-solved",
    "href": "data_management.html#mystery-solved",
    "title": "36  Data Management",
    "section": "36.1 Mystery solved!",
    "text": "36.1 Mystery solved!\nThat’s it for now, my fellow detectives! With your new data management and file operation skills, you’re well on your way to becoming a master Data Detective! Next, we’ll tackle the mysteries of interacting with real-world latency. So keep your watch close at hand!"
  },
  {
    "objectID": "dart_ecosystem.html",
    "href": "dart_ecosystem.html",
    "title": "37  Exploring Dart’s Ecosystem",
    "section": "",
    "text": "Packages and Libraries\nDart DevTools"
  },
  {
    "objectID": "dart_ecosystem/packages_and_libraries.html",
    "href": "dart_ecosystem/packages_and_libraries.html",
    "title": "38  Packages and Libraries",
    "section": "",
    "text": "Chapter: Navigating the Dart Universe: Stellar Libraries and Packages\nIn the vast universe of Dart programming, packages and libraries are like the stars and galaxies, each containing a cluster of useful code ready to be discovered and put to work. As brave explorers of the Dart universe, we need to understand how to locate these celestial bodies, set our course towards them, and even construct our own!\nStep 1: Scanning the Universe for a Library or Package\nOur mission begins by heading over to the pub.dev, a vast space observatory that catalogs the many libraries and packages in the Dart universe. Here, you can search for packages that suit your needs, inspect their documentation, and even view source code.\nStep 2: Setting the Course (Downloading a Package)\nOnce you’ve located a package you’d like to use, it’s time to plot a course and bring it onboard. In Dart, we do this by modifying our spaceship’s blueprint, the pubspec.yaml file, to list the package under dependencies:\ndependencies:\n  flutter:\n    sdk: flutter\n  my_chosen_package: ^1.0.0\n\nNext, we perform a system update with the dart pub get command in our terminal. This brings the package onboard our spaceship, ready for our coding journey.\nStep 3: Harnessing the Power of a Library\nNow that we have the package onboard, we can harness the power of its libraries by importing them into our Dart code.\nimport 'package:my_chosen_package/my_chosen_package.dart';\n\nNow you’re able to utilize the functions, classes, and other elements from your chosen package, just like activating the functions of a newly onboarded spacecraft module!\nStep 4: Crafting Your Own Star (Creating a Package)\nCreating your own package is like forging a new star in the Dart universe. To create a new Dart package, we use the dart create command in our terminal:\ndart create -t package-simple my_custom_package\n\nThis creates a new directory with the basic structure of a Dart package, including a lib directory for your Dart code and a pubspec.yaml file to define your package and its dependencies.\nStep 5: Sharing Your Star (Publishing a Package)\nOnce you’ve polished your package and made it shine, you may want to share it with other Dart explorers. Publishing it to pub.dev is like adding your newly forged star to the universe of Dart packages. But before doing so, make sure you’ve followed the Dart package layout conventions.\nThere you have it, brave explorer! You’ve navigated the universe of Dart libraries and packages, discovered how to harness their power, and even learned to forge and share your own stars. Ready for the next leg of our Dart journey?"
  },
  {
    "objectID": "dart_ecosystem/dart_devtools.html",
    "href": "dart_ecosystem/dart_devtools.html",
    "title": "39  Dart DevTools",
    "section": "",
    "text": "Interstellar Navigation System (INS) 101: Understanding Dart DevTools\nHello space explorer! Your journey through the cosmos has been thrilling and sometimes a little tricky, just like coding in Dart. As we’ve seen, a bug in your spaceship code can be as unsettling as a rogue comet whizzing past your ship. Well, it’s time to unpack your secret weapon, your star map of sorts – the Dart DevTools!\nThe Dart DevTools, like your spaceship’s Interstellar Navigation System (INS), can help you navigate through your code, identify bugs, and optimize performance. Much like the INS maps out the stars, galaxies, and interstellar objects, Dart DevTools maps out your code execution, giving you a clear view of your software universe.\nThe Genesis of Dart DevTools\nThe journey of Dart DevTools began when the Dart team, seeing the need for robust tooling support, created it to make the Dart voyage smoother. The goal was to provide a tool that allows developers to inspect their code, understand its execution, and thus squash bugs more efficiently.\nNavigating the Dart DevTools\nLet’s get hands-on with Dart DevTools! You will learn how to steer your ship (code) smoothly through the cosmic anomalies (bugs) that may come your way.\n\nFlutter Inspector: Like a cosmic radar, the Flutter Inspector scans your UI and shows a live visual tree of your Flutter widgets. It’s great for understanding the widget tree and can help you solve any layout issues in your Flutter UI.\n\n// For using Flutter Inspector, you need to be running a Flutter app.\n// Then, you can see the visual representation of your widget tree.\n\n\nTimeline View: The Timeline View shows you a detailed view of all the events happening as your app runs, just like an INS recording all the cosmic events during your journey. It can help you identify performance issues in your app.\n\n// Run your Dart app and explore the Timeline View in Dart DevTools.\n// This will give you insights into the performance characteristics of your app.\n\n\nMemory View: The Memory View is like checking your spaceship’s fuel and resource usage. It allows you to see how much memory your Dart app is using, which can be critical in identifying memory leaks.\n\n// While running your app, check Memory View in Dart DevTools.\n// Look for anomalies and spikes that might indicate a problem.\n\n\nDebugger: The Debugger is your co-pilot helping you spot and squash the bugs. It allows you to step through your code line by line, inspect variables, and set breakpoints.\n\n// Run your app and open the Debugger in Dart DevTools.\n// Use breakpoints and step through the code to understand its flow.\n\nExploring the Dart DevTools is like understanding your INS; it’s a critical part of your journey. So, brave explorer, may your journey through the cosmos of Dart be bug-free and thrilling! Happy coding and safe interstellar travels!"
  },
  {
    "objectID": "philosophy_of_code.html#the-philosophy-of-code-embracing-errors-and-other-wisdom",
    "href": "philosophy_of_code.html#the-philosophy-of-code-embracing-errors-and-other-wisdom",
    "title": "40  Philosophy of Code",
    "section": "40.1 The Philosophy of Code: Embracing Errors and Other Wisdom",
    "text": "40.1 The Philosophy of Code: Embracing Errors and Other Wisdom\nOnce upon a binary time, a young coder sat hunched over a keyboard, a fresh error message blinking on the screen like a neon sign outside a late-night diner. Let’s eavesdrop on their soliloquy, shall we?\n“Another mistake!” they exclaimed, dramatically throwing their hands in the air. “Why, Code Universe? Why must I always falter?”\nWell, dear reader, it’s because…\n\n40.1.1 Mistakes are Our Greatest Teachers\nMistakes in coding, much like tripping over an untied shoelace, teach us where to look the next time. When our code responds with an error instead of a cheery “Hello, World!” it’s not being malicious. It’s simply the universe’s way of saying, “Nice try, but here’s a learning opportunity.”\nImagine if our coder, instead of treating every error as a defeat, saw it as a plot twist in their coding journey. “Oh, a Null Pointer Exception, you say? What an unexpected surprise! Time to grab my Detective Hat and solve this mystery.”\n\n\n40.1.2 The Power of Persistence\nOur coder friend might feel like they’re banging their head against a semicolon-shaped wall, but guess what? Every great coder has been there. The code is stubborn. It refuses to cooperate until we discover the magic spell - the right combination of logic and syntax - to charm it into submission. That stubbornness can be annoying, but it’s also what makes coding so rewarding. It’s not just about the destination (though a working program feels pretty good); the journey, with all its looping detours and recursive wrong turns, truly makes a coder.\n\n\n40.1.3 Iterative Improvement\nThink of the first draft of your code as a blob of clay. Yes, it’s lumpy and unrecognizable, but with a bit of molding here (refactoring) and trimming there (optimizing), it will start to take shape. Remember, Rome wasn’t coded in a day.\n\n\n40.1.4 Curiosity and Creativity\nCoding isn’t all logic and left-brained. It’s a playground for curiosity and creativity. Think of each new project as a ‘What if?’ scenario. ‘What if I tried this new approach?’ ‘What if I designed it this way?’ Stay curious, stay creative, and who knows? You might just code the next big thing.\n\n\n40.1.5 The Importance of Community\nCoding can seem like a lonely pursuit, but in reality, it’s a worldwide community of thinkers, tinkerers, and problem solvers. Be bold and ask for help or share your own experiences. It’s not a sign of weakness but of strength. In the words of the Beatles, we get by with a little help from our friends (or fellow coders).\nSo next time you encounter a bug, remember you’re not just fixing an error. You’re learning, growing, and contributing to the grand, ongoing adventure that is coding.\nAnd finally, let coding be a tool for change. Use it to solve problems, big and small, in your life and the lives of those around you. Because code isn’t just about instructing a machine – it’s about improving the human experience, one line at a time."
  },
  {
    "objectID": "practical_applications.html",
    "href": "practical_applications.html",
    "title": "41  Practical Applications",
    "section": "",
    "text": "To learn to program, it is essential to practice regularly, along with studying books and articles. Staying motivated when building something interesting or personally beneficial is often easier. Keep a notebook or digital list of project ideas as they arise daily.\nAs a start, here are some real-world command-line applications and scripts that can be developed with Dart to enhance and demonstrate your programming skills:\n\nFile Organizer: Create a script that organizes files in a directory based on their type or last modified date.\nCommand-line Calculator: A simple calculator that performs basic arithmetic operations.\nText-based Adventure Game: Develop a simple, interactive, text-based game.\nTodo List Manager: A command-line app to manage a to-do list, with the ability to add, edit, and delete tasks.\nExpense Tracker: An application to track income and expenses.\nWeather CLI: A tool for fetching and displaying weather data from an API.\nMarkdown to HTML Converter: Convert markdown files to HTML.\nWebsite Status Checker: Check if a website is up by making HTTP requests and checking the response.\nWord Count Tool: Analyze a text file and report the number of words, lines, characters, etc.\nFile Backup Script: Backs up files to a specific directory or external storage.\nCSV to JSON Converter: Convert data from CSV format to JSON.\nQuiz Application: A command-line quiz game with multiple-choice questions.\nDictionary CLI: An application that fetches and displays the definition of a word.\nReminder Application: Set reminders for important tasks, and the application notifies you.\nCode Formatter: A script that formats Dart code according to Dart style guidelines.\nDirectory Tree Generator: Generate and print the directory tree of a given directory.\nAPI Tester: A tool to test API endpoints and view their responses.\nFTP Client: A command-line FTP client for transferring files.\nNote Taker: A command-line application for quickly jotting down notes.\nSimple HTTP Server: A rudimentary HTTP server using Dart’s dart:io library.\n\nThese projects provide hands-on experience with various aspects of Dart programming, such as handling user input, working with file systems, making HTTP requests, parsing data, and more. They are excellent stepping stones for beginners to showcase their proficiency in Dart and enhance their programming skills."
  }
]